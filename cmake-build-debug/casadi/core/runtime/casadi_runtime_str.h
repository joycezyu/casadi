const char* casadi_axpy_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"axpy\"\n"
  "template<typename T1>\n"
  "void casadi_axpy(casadi_int n, T1 alpha, const T1* x, T1* y) {\n"
  "  casadi_int i;\n"
  "  if (!x || !y) return;\n"
  "  for (i=0; i<n; ++i) *y++ += alpha**x++;\n"
  "}\n";

const char* casadi_bilin_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"bilin\"\n"
  "template<typename T1>\n"
  "T1 casadi_bilin(const T1* A, const casadi_int* sp_A, const T1* x, const T1* y) {\n"
  "  casadi_int ncol_A, cc, rr, el;\n"
  "  const casadi_int *colind_A, *row_A;\n"
  "  T1 ret;\n"
  "  // Get sparsities\n"
  "  ncol_A = sp_A[1];\n"
  "  colind_A = sp_A+2; row_A = sp_A + 2 + ncol_A+1;\n"
  "  // Return value\n"
  "  ret=0;\n"
  "  // Loop over the columns of A\n"
  "  for (cc=0; cc<ncol_A; ++cc) {\n"
  "    // Loop over the nonzeros of A\n"
  "    for (el=colind_A[cc]; el<colind_A[cc+1]; ++el) {\n"
  "      // Get the row\n"
  "      rr=row_A[el];\n"
  "      // Add contribution\n"
  "      ret += x[rr]*A[el]*y[cc];\n"
  "    }\n"
  "  }\n"
  "  return ret;\n"
  "}\n";

const char* casadi_copy_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"copy\"\n"
  "template<typename T1>\n"
  "void casadi_copy(const T1* x, casadi_int n, T1* y) {\n"
  "  casadi_int i;\n"
  "  if (y) {\n"
  "    if (x) {\n"
  "      for (i=0; i<n; ++i) *y++ = *x++;\n"
  "    } else {\n"
  "      for (i=0; i<n; ++i) *y++ = 0.;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_de_boor_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"de_boor\"\n"
  "template<typename T1>\n"
  "void casadi_de_boor(T1 x, const T1* knots, casadi_int n_knots, casadi_int degree, T1* boor) {\n"
  "  // length boor: n_knots-1\n"
  "  casadi_int d, i;\n"
  "  for (d=1;d<degree+1;++d) {\n"
  "    for (i=0;i<n_knots-d-1;++i) {\n"
  "      T1 b, bottom;\n"
  "      b = 0;\n"
  "      bottom = knots[i + d] - knots[i];\n"
  "      if (bottom) b = (x - knots[i]) * boor[i] / bottom;\n"
  "      bottom = knots[i + d + 1] - knots[i + 1];\n"
  "      if (bottom) b += (knots[i + d + 1] - x) * boor[i + 1] / bottom;\n"
  "      boor[i] = b;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_densify_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"densify\"\n"
  "template<typename T1, typename T2>\n"
  "void casadi_densify(const T1* x, const casadi_int* sp_x, T2* y, casadi_int tr) {\n"
  "  casadi_int nrow_x, ncol_x, i, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  // Quick return - output ignored\n"
  "  if (!y) return;\n"
  "  nrow_x = sp_x[0]; ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;\n"
  "  // Zero out return value\n"
  "  casadi_fill(y, nrow_x*ncol_x, CASADI_CAST(T2, 0));\n"
  "  // Quick return - input is zero\n"
  "  if (!x) return;\n"
  "  // Copy nonzeros\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n"
  "        y[i + row_x[el]*ncol_x] = CASADI_CAST(T2, *x++);\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {\n"
  "        y[row_x[el] + i*nrow_x] = CASADI_CAST(T2, *x++);\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_dot_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"dot\"\n"
  "template<typename T1>\n"
  "T1 casadi_dot(casadi_int n, const T1* x, const T1* y) {\n"
  "  casadi_int i;\n"
  "  T1 r = 0;\n"
  "  for (i=0; i<n; ++i) r += *x++ * *y++;\n"
  "  return r;\n"
  "}\n";

const char* casadi_fill_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"fill\"\n"
  "template<typename T1>\n"
  "void casadi_fill(T1* x, casadi_int n, T1 alpha) {\n"
  "  casadi_int i;\n"
  "  if (x) {\n"
  "    for (i=0; i<n; ++i) *x++ = alpha;\n"
  "  }\n"
  "}\n";

const char* casadi_flip_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"flip\"\n"
  "inline\n"
  "casadi_int casadi_flip(casadi_int* corner, casadi_int ndim) {\n"
  "  casadi_int i;\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    if (corner[i]) {\n"
  "      corner[i]=0;\n"
  "    } else {\n"
  "      corner[i]=1;\n"
  "      return 1;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n";

const char* casadi_getu_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"getu\"\n"
  "template<typename T1>\n"
  "void casadi_getu(const T1* x, const casadi_int* sp_x, T1* v) {\n"
  "  casadi_int ncol_x, cc, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  // Loop over the columns of x\n"
  "  for (cc=0; cc<ncol_x; ++cc) {\n"
  "    // Loop over the nonzeros of x\n"
  "    for (el=colind_x[cc]; el<colind_x[cc+1] && row_x[el]<=cc; ++el) {\n"
  "      *v++ = x[el];\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_iamax_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"iamax\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_iamax(casadi_int n, const T1* x, casadi_int inc_x) {\n"
  "  casadi_int largest_index, i;\n"
  "  T1 t, largest_value;\n"
  "  largest_value = -1.0;\n"
  "  largest_index = -1;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    t = fabs(*x);\n"
  "    x += inc_x;\n"
  "    if (t>largest_value) {\n"
  "      largest_value = t;\n"
  "      largest_index = i;\n"
  "    }\n"
  "  }\n"
  "  return largest_index;\n"
  "}\n";

const char* casadi_interpn_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn\"\n"
  "template<typename T1>\n"
  "void casadi_interpn(T1* res, casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* values, const T1* x, const casadi_int* lookup_mode, casadi_int m, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  // Work vectors\n"
  "  T1* alpha;\n"
  "  casadi_int *index, *corner;\n"
  "  alpha = w; w += ndim;\n"
  "  index = iw; iw += ndim;\n"
  "  corner = iw; iw += ndim;\n"
  "  // Left index and fraction of interval\n"
  "  casadi_interpn_weights(ndim, grid, offset, x, alpha, index, lookup_mode);\n"
  "  // Loop over all corners, add contribution to output\n"
  "  casadi_fill_casadi_int(corner, ndim, 0);\n"
  "  casadi_fill(res, m, 0.0);\n"
  "  do {\n"
  "    T1* coeff = 0;\n"
  "    casadi_interpn_interpolate(res, ndim, offset, values,\n"
  "      alpha, index, corner, coeff, m);\n"
  "  } while (casadi_flip(corner, ndim));\n"
  "}\n";

const char* casadi_interpn_grad_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_grad\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_grad(T1* grad, casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* values, const T1* x, const casadi_int* lookup_mode, casadi_int m, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  T1 *alpha, *coeff, *v;\n"
  "  casadi_int *index, *corner;\n"
  "  casadi_int i;\n"
  "  // Quick return\n"
  "  if (!grad) return;\n"
  "  // Work vectors\n"
  "  alpha = w; w += ndim;\n"
  "  coeff = w; w += ndim;\n"
  "  v = w; w+= m;\n"
  "  index = iw; iw += ndim;\n"
  "  corner = iw; iw += ndim;\n"
  "  // Left index and fraction of interval\n"
  "  casadi_interpn_weights(ndim, grid, offset, x, alpha, index, lookup_mode);\n"
  "  // Loop over all corners, add contribution to output\n"
  "  casadi_fill_casadi_int(corner, ndim, 0);\n"
  "  casadi_fill(grad, ndim*m, 0.);\n"
  "  do {\n"
  "    casadi_int i, j;\n"
  "    // Get coefficients\n"
  "    casadi_fill(v, m, 0.);\n"
  "    casadi_interpn_interpolate(v, ndim, offset, values,\n"
  "      alpha, index, corner, coeff, m);\n"
  "    // Propagate to alpha\n"
  "    for (i=ndim-1; i>=0; --i) {\n"
  "      if (corner[i]) {\n"
  "        for (j=0; j<m; ++j) {\n"
  "          grad[i*m+j] += v[j]*coeff[i];\n"
  "          v[j] *= alpha[i];\n"
  "        }\n"
  "      } else {\n"
  "        for (j=0; j<m; ++j) {\n"
  "          grad[i*m+j] -= v[j]*coeff[i];\n"
  "          v[j] *= 1-alpha[i];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } while (casadi_flip(corner, ndim));\n"
  "  // Propagate to x\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    casadi_int k, j;\n"
  "    const T1* g;\n"
  "    T1 delta;\n"
  "    g = grid + offset[i];\n"
  "    j = index[i];\n"
  "    delta =  g[j+1]-g[j];\n"
  "    for (k=0;k<m;++k) grad[k] /= delta;\n"
  "    grad += m;\n"
  "  }\n"
  "}\n";

const char* casadi_interpn_interpolate_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_interpolate\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_interpolate(T1* res, casadi_int ndim, const casadi_int* offset, const T1* values, const T1* alpha, const casadi_int* index, const casadi_int* corner, T1* coeff, casadi_int m) { // NOLINT(whitespace/line_length)\n"
  "  T1 c;\n"
  "  casadi_int ld, i;\n"
  "  // Get weight and value for corner\n"
  "  c=1;\n"
  "  ld=1; // leading dimension\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    if (coeff) *coeff++ = c;\n"
  "    if (corner[i]) {\n"
  "      c *= alpha[i];\n"
  "    } else {\n"
  "      c *= 1-alpha[i];\n"
  "    }\n"
  "    values += (index[i]+corner[i])*ld*m;\n"
  "    ld *= offset[i+1]-offset[i];\n"
  "  }\n"
  "  if (coeff) {\n"
  "    for (i=0;i<m;++i) res[i] += values[i];\n"
  "  } else {\n"
  "    for (i=0;i<m;++i) res[i] += c*values[i];\n"
  "  }\n"
  "}\n";

const char* casadi_interpn_weights_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"interpn_weights\"\n"
  "template<typename T1>\n"
  "void casadi_interpn_weights(casadi_int ndim, const T1* grid, const casadi_int* offset, const T1* x, T1* alpha, casadi_int* index, const casadi_int* lookup_mode) { // NOLINT(whitespace/line_length)\n"
  "  // Left index and fraction of interval\n"
  "  casadi_int i;\n"
  "  for (i=0; i<ndim; ++i) {\n"
  "    casadi_int ng, j;\n"
  "    T1 xi;\n"
  "    const T1* g;\n"
  "    // Grid point\n"
  "    xi = x ? x[i] : 0;\n"
  "    // Grid\n"
  "    g = grid + offset[i];\n"
  "    ng = offset[i+1]-offset[i];\n"
  "    // Find left index\n"
  "    j = index[i] = casadi_low(xi, g, ng, lookup_mode[i]);\n"
  "    // Get interpolation/extrapolation alpha\n"
  "    alpha[i] = (xi-g[j])/(g[j+1]-g[j]);\n"
  "  }\n"
  "}\n";

const char* casadi_low_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"low\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_low(T1 x, const double* grid, casadi_int ng, casadi_int lookup_mode) {\n"
  "  switch (lookup_mode) {\n"
  "    case 1: // exact\n"
  "      {\n"
  "        double g0, dg;\n"
  "        casadi_int ret;\n"
  "        g0 = grid[0];\n"
  "        dg = grid[ng-1]-g0;\n"
  "        ret = (casadi_int) ((x-g0)*(ng-1)/dg); // NOLINT(readability/casting)\n"
  "        if (ret<0) ret=0;\n"
  "        if (ret>ng-2) ret=ng-2;\n"
  "        return ret;\n"
  "      }\n"
  "    case 2: // binary\n"
  "      {\n"
  "        casadi_int start, stop, pivot;\n"
  "        // Quick return\n"
  "        if (ng<2 || x<grid[1]) return 0;\n"
  "        if (x>grid[ng-1]) return ng-2;\n"
  "        start = 0;\n"
  "        stop  = ng-1;\n"
  "        while (1) {\n"
  "          pivot = (stop+start)/2;\n"
  "          if (x < grid[pivot]) {\n"
  "            if (pivot==stop) return pivot;\n"
  "            stop = pivot;\n"
  "          } else {\n"
  "            if (pivot==start) return pivot;\n"
  "            start = pivot;\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    default: // linear\n"
  "      {\n"
  "        casadi_int i;\n"
  "        for (i=0; i<ng-2; ++i) {\n"
  "          if (x < grid[i+1]) break;\n"
  "        }\n"
  "        return i;\n"
  "      }\n"
  "  }\n"
  "}\n";

const char* casadi_max_viol_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"max_viol\"\n"
  "template<typename T1>\n"
  "T1 casadi_max_viol(casadi_int n, const T1* x, const T1* lb, const T1* ub) {\n"
  "  T1 r;\n"
  "  casadi_int i;\n"
  "  const T1 zero = 0;\n"
  "  r = 0;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    T1 x_i, lb_i, ub_i;\n"
  "    x_i = x ? *x++ : zero;\n"
  "    lb_i = lb ? *lb++ : zero;\n"
  "    ub_i = ub ? *ub++ : zero;\n"
  "    r = fmax(r, fmax(x_i-ub_i, zero));\n"
  "    r = fmax(r, fmax(lb_i-x_i, zero));\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_minmax_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"std::numeric_limits<double>::infinity()\" \"INF\"\n"
  "// SYMBOL \"mmin\"\n"
  "template<typename T1>\n"
  "T1 casadi_mmin(const T1* x, casadi_int n, casadi_int is_dense) {\n"
  "  casadi_int i;\n"
  "  T1 r = is_dense ? std::numeric_limits<double>::infinity() : 0;\n"
  "  if (!x) return r;\n"
  "  for (i=0; i<n; ++i) r = fmin(r, x[i]);\n"
  "  return r;\n"
  "}\n"
  "// SYMBOL \"mmax\"\n"
  "template<typename T1>\n"
  "T1 casadi_mmax(const T1* x, casadi_int n, casadi_int is_dense) {\n"
  "  casadi_int i;\n"
  "  T1 r = is_dense ? -std::numeric_limits<double>::infinity() : 0;\n"
  "  if (!x) return r;\n"
  "  for (i=0; i<n; ++i) r = fmax(r, x[i]);\n"
  "  return r;\n"
  "}\n";

const char* casadi_mtimes_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mtimes\"\n"
  "template<typename T1>\n"
  "void casadi_mtimes(const T1* x, const casadi_int* sp_x, const T1* y, const casadi_int* sp_y, T1* z, const casadi_int* sp_z, T1* w, casadi_int tr) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int ncol_x, ncol_y, ncol_z, cc;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y, *colind_z, *row_z;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  ncol_z = sp_z[1];\n"
  "  colind_z = sp_z+2; row_z = sp_z + 2 + ncol_z+1;\n"
  "  if (tr) {\n"
  "    // Loop over the columns of y and z\n"
  "    for (cc=0; cc<ncol_z; ++cc) {\n"
  "      casadi_int kk;\n"
  "      // Get the dense column of y\n"
  "      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n"
  "        w[row_y[kk]] = y[kk];\n"
  "      }\n"
  "      // Loop over the nonzeros of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        casadi_int kk1;\n"
  "        casadi_int rr = row_z[kk];\n"
  "        // Loop over corresponding columns of x\n"
  "        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n"
  "          z[kk] += x[kk1] * w[row_x[kk1]];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Loop over the columns of y and z\n"
  "    for (cc=0; cc<ncol_y; ++cc) {\n"
  "      casadi_int kk;\n"
  "      // Get the dense column of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        w[row_z[kk]] = z[kk];\n"
  "      }\n"
  "      // Loop over the nonzeros of y\n"
  "      for (kk=colind_y[cc]; kk<colind_y[cc+1]; ++kk) {\n"
  "        casadi_int kk1;\n"
  "        casadi_int rr = row_y[kk];\n"
  "        // Loop over corresponding columns of x\n"
  "        for (kk1=colind_x[rr]; kk1<colind_x[rr+1]; ++kk1) {\n"
  "          w[row_x[kk1]] += x[kk1]*y[kk];\n"
  "        }\n"
  "      }\n"
  "      // Get the sparse column of z\n"
  "      for (kk=colind_z[cc]; kk<colind_z[cc+1]; ++kk) {\n"
  "        z[kk] = w[row_z[kk]];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_mv_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mv\"\n"
  "template<typename T1>\n"
  "void casadi_mv(const T1* x, const casadi_int* sp_x, const T1* y, T1* z, casadi_int tr) {\n"
  "  casadi_int ncol_x, i, el;\n"
  "  const casadi_int *colind_x, *row_x;\n"
  "  if (!x || !y || !z) return;\n"
  "  // Get sparsities\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  if (tr) {\n"
  "    // loop over the columns of x\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      // loop over the non-zeros of x\n"
  "      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n"
  "        z[i] += x[el] * y[row_x[el]];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // loop over the columns of x\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      // loop over the non-zeros of x\n"
  "      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {\n"
  "        z[row_x[el]] += x[el] * y[i];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_mv_dense_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"mv_dense\"\n"
  "template<typename T1>\n"
  "void casadi_mv_dense(const T1* x, casadi_int nrow_x, casadi_int ncol_x,\n"
  "    const T1* y, T1* z, casadi_int tr) {\n"
  "  casadi_int i, j;\n"
  "  if (!x || !y || !z) return;\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (j=0; j<nrow_x; ++j) {\n"
  "        z[i] += *x++ * y[j];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_x; ++i) {\n"
  "      for (j=0; j<nrow_x; ++j) {\n"
  "        z[j] += *x++ * y[i];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_nd_boor_eval_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"nd_boor_eval\"\n"
  "template<typename T1>\n"
  "void casadi_nd_boor_eval(T1* ret, casadi_int n_dims, const T1* all_knots, const casadi_int* offset, const casadi_int* all_degree, const casadi_int* strides, const T1* c, casadi_int m, const T1* all_x, const casadi_int* lookup_mode, casadi_int reverse, casadi_int* iw, T1* w) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int n_iter, k, i, pivot;\n"
  "  casadi_int *boor_offset, *starts, *index, *coeff_offset;\n"
  "  T1 *cumprod, *all_boor;\n"
  "  boor_offset = iw; iw+=n_dims+1;\n"
  "  starts = iw; iw+=n_dims;\n"
  "  index = iw; iw+=n_dims;\n"
  "  coeff_offset = iw;\n"
  "  cumprod = w; w+= n_dims+1;\n"
  "  all_boor = w;\n"
  "  boor_offset[0] = 0;\n"
  "  cumprod[n_dims] = 1;\n"
  "  coeff_offset[n_dims] = 0;\n"
  "  n_iter = 1;\n"
  "  for (k=0;k<n_dims;++k) {\n"
  "    T1 *boor;\n"
  "    const T1* knots;\n"
  "    T1 x;\n"
  "    casadi_int degree, n_knots, n_b, L, start;\n"
  "    boor = all_boor+boor_offset[k];\n"
  "    degree = all_degree[k];\n"
  "    knots = all_knots + offset[k];\n"
  "    n_knots = offset[k+1]-offset[k];\n"
  "    n_b = n_knots-degree-1;\n"
  "    x = all_x[k];\n"
  "    L = casadi_low(x, knots+degree, n_knots-2*degree, lookup_mode[k]);\n"
  "    start = L;\n"
  "    if (start>n_b-degree-1) start = n_b-degree-1;\n"
  "    starts[k] = start;\n"
  "    casadi_fill(boor, 2*degree+1, 0.0);\n"
  "    if (x>=knots[0] && x<=knots[n_knots-1]) {\n"
  "      if (x==knots[1]) {\n"
  "        casadi_fill(boor, degree+1, 1.0);\n"
  "      } else if (x==knots[n_knots-1]) {\n"
  "        boor[degree] = 1;\n"
  "      } else if (knots[L+degree]==x) {\n"
  "        boor[degree-1] = 1;\n"
  "      } else {\n"
  "        boor[degree] = 1;\n"
  "      }\n"
  "    }\n"
  "    casadi_de_boor(x, knots+start, 2*degree+2, degree, boor);\n"
  "    boor+= degree+1;\n"
  "    n_iter*= degree+1;\n"
  "    boor_offset[k+1] = boor_offset[k] + degree+1;\n"
  "  }\n"
  "  casadi_fill_casadi_int(index, n_dims, 0);\n"
  "  // Prepare cumulative product\n"
  "  for (pivot=n_dims-1;pivot>=0;--pivot) {\n"
  "    cumprod[pivot] = (*(all_boor+boor_offset[pivot]))*cumprod[pivot+1];\n"
  "    coeff_offset[pivot] = starts[pivot]*strides[pivot]+coeff_offset[pivot+1];\n"
  "  }\n"
  "  for (k=0;k<n_iter;++k) {\n"
  "    casadi_int pivot = 0;\n"
  "    // accumulate result\n"
  "    for (i=0;i<m;++i) {\n"
  "      if (reverse) {\n"
  "        ret[coeff_offset[0]+i] += c[i]*cumprod[0];\n"
  "      } else {\n"
  "        ret[i] += c[coeff_offset[0]+i]*cumprod[0];\n"
  "      }\n"
  "    }\n"
  "    // Increment index\n"
  "    index[0]++;\n"
  "    // Handle index overflow\n"
  "    {\n"
  "      // increment next index (forward)\n"
  "      while (index[pivot]==boor_offset[pivot+1]-boor_offset[pivot]) {\n"
  "        index[pivot] = 0;\n"
  "        if (pivot==n_dims-1) break;\n"
  "        index[++pivot]++;\n"
  "      }\n"
  "      // update cumulative structures (reverse)\n"
  "      while (pivot>0) {\n"
  "        // Compute product\n"
  "        cumprod[pivot] = (*(all_boor+boor_offset[pivot]+index[pivot]))*cumprod[pivot+1];\n"
  "        // Compute offset\n"
  "        coeff_offset[pivot] = (starts[pivot]+index[pivot])*strides[pivot]+coeff_offset[pivot+1];\n"
  "        pivot--;\n"
  "      }\n"
  "    }\n"
  "    // Compute product\n"
  "    cumprod[0] = (*(all_boor+index[0]))*cumprod[1];\n"
  "    // Compute offset\n"
  "    coeff_offset[0] = (starts[0]+index[0])*m+coeff_offset[1];\n"
  "  }\n"
  "}\n";

const char* casadi_norm_1_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_1\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_1(casadi_int n, const T1* x) {\n"
  "  casadi_int i;\n"
  "  T1 ret = 0;\n"
  "  if (x) {\n"
  "    for (i=0; i<n; ++i) ret += fabs(*x++);\n"
  "  }\n"
  "  return ret;\n"
  "}\n";

const char* casadi_norm_2_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_2\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_2(casadi_int n, const T1* x) {\n"
  "  return sqrt(casadi_dot(n, x, x));\n"
  "}\n";

const char* casadi_norm_inf_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_inf\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_inf(casadi_int n, const T1* x) {\n"
  "  casadi_int i;\n"
  "  T1 ret = 0;\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "  for (i=0; i<n; ++i) ret = fmax(ret, fabs(*x++));\n"
  "  return ret;\n"
  "}\n";

const char* casadi_norm_inf_mul_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"norm_inf_mul\"\n"
  "template<typename T1>\n"
  "T1 casadi_norm_inf_mul(const T1* x, const casadi_int* sp_x, const T1* y, const casadi_int* sp_y, T1* dwork, casadi_int* iwork) { // NOLINT(whitespace/line_length)\n"
  "  casadi_int nrow_x, ncol_x, ncol_y, i, jj, kk, nnz;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y;\n"
  "  casadi_int *mask, *next;\n"
  "  T1 res = 0;\n"
  "  // Get sparsities\n"
  "  nrow_x = sp_x[0]; ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  // Implementation inspired on Scipy's sparsetools/csr.h\n"
  "  // method that uses O(n) temp storage\n"
  "  mask = iwork + ncol_y+1;\n"
  "  // Pass 1\n"
  "  for (i=0; i<nrow_x; ++i) mask[i] = -1;\n"
  "  iwork[0] = 0;\n"
  "  nnz = 0;\n"
  "  for (i=0; i<ncol_y; ++i) {\n"
  "    casadi_int next_nnz;\n"
  "    casadi_int row_nnz = 0;\n"
  "    for (jj=colind_y[i]; jj < colind_y[i+1]; jj++) {\n"
  "      casadi_int j = row_y[jj];\n"
  "      for (kk=colind_x[j]; kk < colind_x[j+1]; kk++) {\n"
  "        casadi_int k = row_x[kk];\n"
  "        if (mask[k] != i) {\n"
  "          mask[k] = i;\n"
  "          row_nnz++;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    next_nnz = nnz + row_nnz;\n"
  "    nnz = next_nnz;\n"
  "    iwork[i+1] = nnz;\n"
  "  }\n"
  "  // Pass 2\n"
  "  next = iwork + ncol_y+1;\n"
  "  for (i=0; i<nrow_x; ++i) next[i] = -1;\n"
  "  T1* sums = dwork;\n"
  "  for (i=0; i<nrow_x; ++i) sums[i] = 0;\n"
  "  nnz = 0;\n"
  "  iwork[0] = 0;\n"
  "  for (i=0; i<ncol_y; ++i) {\n"
  "    casadi_int head, length, jj_start, jj_end;\n"
  "    head   = -2;\n"
  "    length =  0;\n"
  "    jj_start = colind_y[i];\n"
  "    jj_end   = colind_y[i+1];\n"
  "    for (jj=jj_start; jj<jj_end; ++jj) {\n"
  "      casadi_int j, kk_start, kk_end;\n"
  "      T1 v;\n"
  "      j = row_y[jj];\n"
  "      v = y[jj];\n"
  "      kk_start = colind_x[j];\n"
  "      kk_end   = colind_x[j+1];\n"
  "      for (kk = kk_start; kk<kk_end; ++kk) {\n"
  "        casadi_int k = row_x[kk];\n"
  "        sums[k] += v*x[kk];\n"
  "        if (next[k] == -1) {\n"
  "          next[k] = head;\n"
  "          head  = k;\n"
  "          length++;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    for (jj=0; jj<length; ++jj) {\n"
  "      casadi_int temp;\n"
  "      if (!is_zero(sums[head])) {\n"
  "        T1 a = fabs(sums[head]);\n"
  "        res = fmax(res, a);\n"
  "        nnz++;\n"
  "      }\n"
  "      temp = head;\n"
  "      head = next[head];\n"
  "      next[temp] = -1; //clear arrays\n"
  "      sums[temp] =  0;\n"
  "    }\n"
  "    iwork[i+1] = nnz;\n"
  "  }\n"
  "  return res;\n"
  "}\n";

const char* casadi_polyval_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"polyval\"\n"
  "template<typename T1>\n"
  "T1 casadi_polyval(const T1* p, casadi_int n, T1 x) {\n"
  "  casadi_int i;\n"
  "  T1 r=p[0];\n"
  "  for (i=1; i<=n; ++i) {\n"
  "    r = r*x + p[i];\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_project_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"project\"\n"
  "template<typename T1>\n"
  "void casadi_project(const T1* x, const casadi_int* sp_x, T1* y, const casadi_int* sp_y, T1* w) {\n"
  "  casadi_int ncol_x, ncol_y, i, el;\n"
  "  const casadi_int *colind_x, *row_x, *colind_y, *row_y;\n"
  "  ncol_x = sp_x[1];\n"
  "  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y + 2 + ncol_y+1;\n"
  "  // Loop over columns of x and y\n"
  "  for (i=0; i<ncol_x; ++i) {\n"
  "    // Zero out requested entries in y\n"
  "    for (el=colind_y[i]; el<colind_y[i+1]; ++el) w[row_y[el]] = 0;\n"
  "    // Set x entries\n"
  "    for (el=colind_x[i]; el<colind_x[i+1]; ++el) w[row_x[el]] = x[el];\n"
  "    // Retrieve requested entries in y\n"
  "    for (el=colind_y[i]; el<colind_y[i+1]; ++el) y[el] = w[row_y[el]];\n"
  "  }\n"
  "}\n";

const char* casadi_rank1_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"rank1\"\n"
  "template<typename T1>\n"
  "void casadi_rank1(T1* A, const casadi_int* sp_A, T1 alpha, const T1* x, const T1* y) {\n"
  "  casadi_int ncol_A, cc, rr, el;\n"
  "  const casadi_int *colind_A, *row_A;\n"
  "  // Get sparsities\n"
  "  ncol_A = sp_A[1];\n"
  "  colind_A = sp_A+2; row_A = sp_A + 2 + ncol_A+1;\n"
  "  // Loop over the columns of A\n"
  "  for (cc=0; cc<ncol_A; ++cc) {\n"
  "    // Loop over the nonzeros of A\n"
  "    for (el=colind_A[cc]; el<colind_A[cc+1]; ++el) {\n"
  "      // Get row\n"
  "      rr = row_A[el];\n"
  "      // Add the multiple\n"
  "      A[el] += alpha*x[rr]*y[cc];\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_scal_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"scal\"\n"
  "template<typename T1>\n"
  "void casadi_scal(casadi_int n, T1 alpha, T1* x) {\n"
  "  casadi_int i;\n"
  "  if (!x) return;\n"
  "  for (i=0; i<n; ++i) *x++ *= alpha;\n"
  "}\n";

const char* casadi_sparsify_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"sparsify\"\n"
  "template<typename T1, typename T2>\n"
  "void casadi_sparsify(const T1* x, T2* y, const casadi_int* sp_y, casadi_int tr) {\n"
  "  casadi_int nrow_y, ncol_y, i, el;\n"
  "  const casadi_int *colind_y, *row_y;\n"
  "  nrow_y = sp_y[0];\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2; row_y = sp_y+ncol_y+3;\n"
  "  if (tr) {\n"
  "    for (i=0; i<ncol_y; ++i) {\n"
  "      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {\n"
  "        *y++ = CASADI_CAST(T2, x[i + row_y[el]*ncol_y]);\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    for (i=0; i<ncol_y; ++i) {\n"
  "      for (el=colind_y[i]; el!=colind_y[i+1]; ++el) {\n"
  "        *y++ = CASADI_CAST(T2, x[row_y[el] + i*nrow_y]);\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_sum_viol_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"sum_viol\"\n"
  "template<typename T1>\n"
  "T1 casadi_sum_viol(casadi_int n, const T1* x, const T1* lb, const T1* ub) {\n"
  "  T1 r;\n"
  "  casadi_int i;\n"
  "  const T1 zero = 0;\n"
  "  r = 0;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    T1 x_i, lb_i, ub_i;\n"
  "    x_i = x ? *x++ : zero;\n"
  "    lb_i = lb ? *lb++ : zero;\n"
  "    ub_i = ub ? *ub++ : zero;\n"
  "    r += fmax(x_i-ub_i, zero);\n"
  "    r += fmax(lb_i-x_i, zero);\n"
  "  }\n"
  "  return r;\n"
  "}\n";

const char* casadi_swap_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"swap\"\n"
  "template<typename T1>\n"
  "void casadi_swap(casadi_int n, T1* x, casadi_int inc_x, T1* y, casadi_int inc_y) {\n"
  "  T1 t;\n"
  "  casadi_int i;\n"
  "  for (i=0; i<n; ++i) {\n"
  "    t = *x;\n"
  "    *x = *y;\n"
  "    *y = t;\n"
  "    x += inc_x;\n"
  "    y += inc_y;\n"
  "  }\n"
  "}\n";

const char* casadi_trans_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"trans\"\n"
  "template<typename T1>\n"
  "void casadi_trans(const T1* x, const casadi_int* sp_x, T1* y,\n"
  "    const casadi_int* sp_y, casadi_int* tmp) {\n"
  "  casadi_int ncol_x, nnz_x, ncol_y, k;\n"
  "  const casadi_int* row_x, *colind_y;\n"
  "  ncol_x = sp_x[1];\n"
  "  nnz_x = sp_x[2 + ncol_x];\n"
  "  row_x = sp_x + 2 + ncol_x+1;\n"
  "  ncol_y = sp_y[1];\n"
  "  colind_y = sp_y+2;\n"
  "  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];\n"
  "  for (k=0; k<nnz_x; ++k) {\n"
  "    y[tmp[row_x[k]]++] = x[k];\n"
  "  }\n"
  "}\n";

const char* casadi_finite_diff_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"finite_diff_mem\"\n"
  "template<typename T1>\n"
  "struct casadi_finite_diff_mem {\n"
  "  // Input precision\n"
  "  T1 reltol;\n"
  "  // Output precision\n"
  "  T1 abstol;\n"
  "  // Smoothness parameter\n"
  "  // Smaller epsilon: More discontinuity rejecting\n"
  "  // Larger epsilon: More accurate (higher order) if smooth\n"
  "  T1 smoothing;\n"
  "};\n"
  "// C-REPLACE \"casadi_finite_diff_mem<T1>\" \"struct casadi_finite_diff_mem\"\n"
  "// C-REPLACE \"std::numeric_limits<T1>::quiet_NaN()\" \"NAN\"\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// SYMBOL \"forward_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_forward_diff(T1** yk, T1* y0, T1* J,\n"
  "                       T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  casadi_int i;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    J[i] = (yk[0][i]-y0[i])/h;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "// SYMBOL \"central_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_central_diff(T1** yk, T1* y0, T1* J,\n"
  "                       T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  // Return value\n"
  "  T1 u;\n"
  "  // Stencil\n"
  "  T1 yf, yc, yb;\n"
  "  // Local variables\n"
  "  T1 err_trunc, err_round;\n"
  "  casadi_int i;\n"
  "  // Set u and stencils to zero (also supresses warnings)\n"
  "  yf = yc = yb = u = 0;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    // Copy to local variables, return -1 if invalid entry\n"
  "    if (!isfinite((yf=yk[1][i])) || !isfinite((yc=y0[i])) || !isfinite((yb=yk[0][i]))) {\n"
  "      J[i] = std::numeric_limits<T1>::quiet_NaN();\n"
  "      u = -1;\n"
  "      continue;\n"
  "    }\n"
  "    // Central difference approximation\n"
  "    J[i] = (yf - yb)/(2*h);\n"
  "    // Truncation error\n"
  "    err_trunc = yf - 2*yc + yb;\n"
  "    // Roundoff error\n"
  "    err_round = m->reltol/h*fmax(fabs(yf-yc), fabs(yc-yb)) + m->abstol;\n"
  "    // Update error estimate\n"
  "    if (u>=0) u = fmax(u, fabs(err_trunc/err_round));\n"
  "  }\n"
  "  return u;\n"
  "}\n"
  "// SYMBOL \"smoothing_diff\"\n"
  "template<typename T1>\n"
  "T1 casadi_smoothing_diff(T1** yk, T1* y0, T1* J,\n"
  "                         T1 h, casadi_int n_y, const casadi_finite_diff_mem<T1>* m) {\n"
  "  // Return value\n"
  "  T1 u;\n"
  "  // Stencil\n"
  "  T1 yb, yc, yf;\n"
  "  // Local variables\n"
  "  T1 Jk, wk, sw, ui, err_trunc, err_round, sm;\n"
  "  casadi_int i, k;\n"
  "  // Set u and stencils to zero (also supresses warnings)\n"
  "  yf = yc = yb = u = 0;\n"
  "  for (i=0; i<n_y; ++i) {\n"
  "    // Reset derivative estimate, sum of weights, error estimate\n"
  "    J[i] = sw = ui = 0;\n"
  "    // For backward shifted, central and forward shifted\n"
  "    for (k=0; k<3; ++k) {\n"
  "      // Calculate shifted finite difference approximation\n"
  "      if (k==0) {\n"
  "        // Backward shifted\n"
  "        // 7.10 in Conte & Carl de Boor: Elementary Numerical Analysis (1972)\n"
  "        // and 25.3.4 in Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\n"
  "        if (!isfinite((yc=yk[0][i]))) continue;\n"
  "        if (!isfinite((yb=yk[1][i]))) continue;\n"
  "        yf = y0[i];\n"
  "        Jk = 3*yf - 4*yc + yb;\n"
  "        wk = 1;\n"
  "      } else if (k==1) {\n"
  "        // Central\n"
  "        // We give this the \"nominal weight\" 4 since if all weights are equal,\n"
  "        // this would amount to a five point formula for the derivative\n"
  "        // (yb2 - 8*yb + 8*yf - y_f2)/(12*h)\n"
  "        // cf. 25.3.6 in Abramowitz and Stegun, Handbook of Mathematical Functions (1964)\n"
  "        if (!isfinite((yf=yk[2][i]))) continue;\n"
  "        if (!isfinite((yb=yc))) continue;\n"
  "        yc = y0[i];\n"
  "        Jk = yf-yb;\n"
  "        wk = 4;\n"
  "      } else {\n"
  "        // Forward shifted\n"
  "        if (!isfinite((yc=yf))) continue;\n"
  "        if (!isfinite((yf=yk[3][i]))) continue;\n"
  "        yb = y0[i];\n"
  "        Jk = -3*yb + 4*yc - yf;\n"
  "        wk = 1;\n"
  "      }\n"
  "      // Truncation error\n"
  "      err_trunc = yf - 2*yc + yb;\n"
  "      // Roundoff error\n"
  "      err_round = m->reltol/h*fmax(fabs(yf-yc), fabs(yc-yb)) + m->abstol;\n"
  "      // We use the second order derivative as a smoothness measure\n"
  "      sm = err_trunc/(h*h);\n"
  "      // Modify the weight according to smoothness\n"
  "      wk /= sm*sm + m->smoothing;\n"
  "      sw += wk;\n"
  "      // Added weighted contribution to weight and error\n"
  "      J[i] += wk * Jk;\n"
  "      ui += wk * fabs(err_trunc/err_round);\n"
  "    }\n"
  "    // If sw is 0, no stencil worked\n"
  "    if (sw==0) {\n"
  "      // Set component to 0, return -1\n"
  "      J[i] = std::numeric_limits<T1>::quiet_NaN();\n"
  "      u = -1;\n"
  "    } else {\n"
  "      // Finalize estimate using the sum of weights and the step length\n"
  "      J[i] /= 2*h*sw;\n"
  "      if (u>=0) u = fmax(u, ui/sw);\n"
  "    }\n"
  "  }\n"
  "  return u;\n"
  "}\n";

const char* casadi_ldl_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"ldl\"\n"
  "// Calculate the nonzeros of the transposed L factor (strictly lower entries only)\n"
  "// as well as D for an LDL^T factorization\n"
  "// len[w] >= n\n"
  "template<typename T1>\n"
  "void casadi_ldl(const casadi_int* sp_a, const T1* a,\n"
  "                const casadi_int* sp_lt, T1* lt, T1* d, const casadi_int* p, T1* w) {\n"
  "  const casadi_int *lt_colind, *lt_row, *a_colind, *a_row;\n"
  "  casadi_int n, r, c, c1, k, k2;\n"
  "  // Extract sparsities\n"
  "  n=sp_lt[1];\n"
  "  lt_colind=sp_lt+2; lt_row=sp_lt+2+n+1;\n"
  "  a_colind=sp_a+2; a_row=sp_a+2+n+1;\n"
  "  // Clear w\n"
  "  for (r=0; r<n; ++r) w[r] = 0;\n"
  "  // Sparse copy of A to L and D\n"
  "  for (c=0; c<n; ++c) {\n"
  "    c1 = p[c];\n"
  "    for (k=a_colind[c1]; k<a_colind[c1+1]; ++k) w[a_row[k]] = a[k];\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) lt[k] = w[p[lt_row[k]]];\n"
  "    d[c] = w[p[c]];\n"
  "    for (k=a_colind[c1]; k<a_colind[c1+1]; ++k) w[a_row[k]] = 0;\n"
  "  }\n"
  "  // Loop over columns of L\n"
  "  for (c=0; c<n; ++c) {\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) {\n"
  "      r = lt_row[k];\n"
  "      // Calculate l(r,c) with r<c\n"
  "      for (k2=lt_colind[r]; k2<lt_colind[r+1]; ++k2) {\n"
  "        lt[k] -= lt[k2] * w[lt_row[k2]];\n"
  "      }\n"
  "      w[r] = lt[k];\n"
  "      lt[k] /= d[r];\n"
  "      // Update d(c)\n"
  "      d[c] -= w[r]*lt[k];\n"
  "    }\n"
  "    // Clear w\n"
  "    for (k=lt_colind[c]; k<lt_colind[c+1]; ++k) w[lt_row[k]] = 0;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"ldl_trs\"\n"
  "// Solve for (I+R) with R an optionally transposed strictly upper triangular matrix.\n"
  "template<typename T1>\n"
  "void casadi_ldl_trs(const casadi_int* sp_r, const T1* nz_r, T1* x, casadi_int tr) {\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_r[1];\n"
  "  colind=sp_r+2; row=sp_r+2+ncol+1;\n"
  "  if (tr) {\n"
  "    // Forward substitution\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        x[c] -= nz_r[k]*x[row[k]];\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Backward substitution\n"
  "    for (c=ncol-1; c>=0; --c) {\n"
  "      for (k=colind[c+1]-1; k>=colind[c]; --k) {\n"
  "        x[row[k]] -= nz_r[k]*x[c];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"ldl_solve\"\n"
  "// Linear solve using an LDL^T factorized linear system\n"
  "template<typename T1>\n"
  "void casadi_ldl_solve(T1* x, casadi_int nrhs, const casadi_int* sp_lt, const T1* lt,\n"
  "                      const T1* d, const casadi_int* p, T1* w) {\n"
  "  casadi_int i, k;\n"
  "  casadi_int n = sp_lt[1];\n"
  "  for (k=0; k<nrhs; ++k) {\n"
  "    // P' L D L' P x = b <=> x = P' L' \\ D \\ L \\ P b\n"
  "    // Multiply by P\n"
  "    for (i=0; i<n; ++i) w[i] = x[p[i]];\n"
  "    //  Solve for L\n"
  "    casadi_ldl_trs(sp_lt, lt, w, 1);\n"
  "    // Divide by D\n"
  "    for (i=0; i<n; ++i) w[i] /= d[i];\n"
  "    // Solve for L'\n"
  "    casadi_ldl_trs(sp_lt, lt, w, 0);\n"
  "    // Multiply by P'\n"
  "    for (i=0; i<n; ++i) x[p[i]] = w[i];\n"
  "    // Next rhs\n"
  "    x += n;\n"
  "  }\n"
  "}\n";

const char* casadi_qr_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"house\"\n"
  "// Householder reflection\n"
  "// Ref: Chapter 5, Direct Methods for Sparse Linear Systems by Tim Davis\n"
  "template<typename T1>\n"
  "T1 casadi_house(T1* v, T1* beta, casadi_int nv) {\n"
  "  // Local variable\n"
  "  casadi_int i;\n"
  "  T1 v0, sigma, s, sigma_is_zero, v0_nonpos;\n"
  "  // Calculate norm\n"
  "  v0 = v[0]; // Save v0 (overwritten below)\n"
  "  sigma=0;\n"
  "  for (i=1; i<nv; ++i) sigma += v[i]*v[i];\n"
  "  s = sqrt(v0*v0 + sigma); // s = norm(v)\n"
  "  // Calculate consistently with symbolic datatypes (SXElem)\n"
  "  sigma_is_zero = sigma==0;\n"
  "  v0_nonpos = v0<=0;\n"
  "  // C-REPLACE \"if_else\" \"casadi_if_else\"\n"
  "  v[0] = if_else(sigma_is_zero, 1,\n"
  "                 if_else(v0_nonpos, v0-s, -sigma/(v0+s)));\n"
  "  *beta = if_else(sigma_is_zero, 2*v0_nonpos, -1/(s*v[0]));\n"
  "  return s;\n"
  "}\n"
  "// SYMBOL \"qr\"\n"
  "// Numeric QR factorization\n"
  "// Ref: Chapter 5, Direct Methods for Sparse Linear Systems by Tim Davis\n"
  "// len[x] = nrow\n"
  "// sp_v = [nrow, ncol, 0, 0, ...] len[3 + ncol + nnz_v]\n"
  "// len[v] nnz_v\n"
  "// sp_r = [nrow, ncol, 0, 0, ...] len[3 + ncol + nnz_r]\n"
  "// len[r] nnz_r\n"
  "// len[beta] ncol\n"
  "template<typename T1>\n"
  "void casadi_qr(const casadi_int* sp_a, const T1* nz_a, T1* x,\n"
  "               const casadi_int* sp_v, T1* nz_v, const casadi_int* sp_r, T1* nz_r, T1* beta,\n"
  "               const casadi_int* prinv, const casadi_int* pc) {\n"
  "   // Local variables\n"
  "   casadi_int ncol, nrow, r, c, k, k1;\n"
  "   T1 alpha;\n"
  "   const casadi_int *a_colind, *a_row, *v_colind, *v_row, *r_colind, *r_row;\n"
  "   // Extract sparsities\n"
  "   ncol = sp_a[1];\n"
  "   a_colind=sp_a+2; a_row=sp_a+2+ncol+1;\n"
  "   nrow = sp_v[0];\n"
  "   v_colind=sp_v+2; v_row=sp_v+2+ncol+1;\n"
  "   r_colind=sp_r+2; r_row=sp_r+2+ncol+1;\n"
  "   // Clear work vector\n"
  "   for (r=0; r<nrow; ++r) x[r] = 0;\n"
  "   // Loop over columns of R, A and V\n"
  "   for (c=0; c<ncol; ++c) {\n"
  "     // Copy (permuted) column of A to x\n"
  "     for (k=a_colind[pc[c]]; k<a_colind[pc[c]+1]; ++k) x[prinv[a_row[k]]] = nz_a[k];\n"
  "     // Use the equality R = (I-betan*vn*vn')*...*(I-beta1*v1*v1')*A to get\n"
  "     // strictly upper triangular entries of R\n"
  "     for (k=r_colind[c]; k<r_colind[c+1] && (r=r_row[k])<c; ++k) {\n"
  "       // Calculate scalar factor alpha = beta(r)*dot(v(:,r), x)\n"
  "       alpha = 0;\n"
  "       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) alpha += nz_v[k1]*x[v_row[k1]];\n"
  "       alpha *= beta[r];\n"
  "       // x -= alpha*v(:,r)\n"
  "       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) x[v_row[k1]] -= alpha*nz_v[k1];\n"
  "       // Get r entry\n"
  "       *nz_r++ = x[r];\n"
  "       // Strictly upper triangular entries in x no longer needed\n"
  "       x[r] = 0;\n"
  "     }\n"
  "     // Get V column\n"
  "     for (k=v_colind[c]; k<v_colind[c+1]; ++k) {\n"
  "       nz_v[k] = x[v_row[k]];\n"
  "       // Lower triangular entries of x no longer needed\n"
  "       x[v_row[k]] = 0;\n"
  "     }\n"
  "     // Get diagonal entry of R, normalize V column\n"
  "     *nz_r++ = casadi_house(nz_v + v_colind[c], beta + c, v_colind[c+1] - v_colind[c]);\n"
  "   }\n"
  " }\n"
  "// SYMBOL \"qr_mv\"\n"
  "// Multiply QR Q matrix from the right with a vector, with Q represented\n"
  "// by the Householder vectors V and beta\n"
  "// x = Q*x or x = Q'*x\n"
  "// with Q = (I-beta(1)*v(:,1)*v(:,1)')*...*(I-beta(n)*v(:,n)*v(:,n)')\n"
  "// len[x] >= nrow_ext\n"
  "template<typename T1>\n"
  "void casadi_qr_mv(const casadi_int* sp_v, const T1* v, const T1* beta, T1* x,\n"
  "                  casadi_int tr) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, c1, k;\n"
  "  T1 alpha;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_v[1];\n"
  "  colind=sp_v+2; row=sp_v+2+ncol+1;\n"
  "  // Loop over vectors\n"
  "  for (c1=0; c1<ncol; ++c1) {\n"
  "    // Forward order for transpose, otherwise backwards\n"
  "    c = tr ? c1 : ncol-1-c1;\n"
  "    // Calculate scalar factor alpha = beta(c)*dot(v(:,c), x)\n"
  "    alpha=0;\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) alpha += v[k]*x[row[k]];\n"
  "    alpha *= beta[c];\n"
  "    // x -= alpha*v(:,c)\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) x[row[k]] -= alpha*v[k];\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_trs\"\n"
  "// Solve for an (optionally transposed) upper triangular matrix R\n"
  "template<typename T1>\n"
  "void casadi_qr_trs(const casadi_int* sp_r, const T1* nz_r, T1* x, casadi_int tr) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, r, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Extract sparsity\n"
  "  ncol=sp_r[1];\n"
  "  colind=sp_r+2; row=sp_r+2+ncol+1;\n"
  "  if (tr) {\n"
  "    // Forward substitution\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        r = row[k];\n"
  "        if (r==c) {\n"
  "          x[c] /= nz_r[k];\n"
  "        } else {\n"
  "          x[c] -= nz_r[k]*x[r];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  } else {\n"
  "    // Backward substitution\n"
  "    for (c=ncol-1; c>=0; --c) {\n"
  "      for (k=colind[c+1]-1; k>=colind[c]; --k) {\n"
  "        r=row[k];\n"
  "        if (r==c) {\n"
  "          x[r] /= nz_r[k];\n"
  "        } else {\n"
  "          x[r] -= nz_r[k]*x[c];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_solve\"\n"
  "// Solve a factorized linear system\n"
  "// len[w] >= max(ncol, nrow_ext)\n"
  "template<typename T1>\n"
  "void casadi_qr_solve(T1* x, casadi_int nrhs, casadi_int tr,\n"
  "                     const casadi_int* sp_v, const T1* v, const casadi_int* sp_r, const T1* r,\n"
  "                     const T1* beta, const casadi_int* prinv, const casadi_int* pc, T1* w) {\n"
  "  casadi_int k, c, nrow_ext, ncol;\n"
  "  nrow_ext = sp_v[0]; ncol = sp_v[1];\n"
  "  for (k=0; k<nrhs; ++k) {\n"
  "    if (tr) {\n"
  "      // (PR' Q R PC)' x = PC' R' Q' PR x = b <-> x = PR' Q R' \\ PC b\n"
  "      // Multiply by PC\n"
  "      for (c=0; c<ncol; ++c) w[c] = x[pc[c]];\n"
  "      //  Solve for R'\n"
  "      casadi_qr_trs(sp_r, r, w, 1);\n"
  "      // Multiply by Q\n"
  "      casadi_qr_mv(sp_v, v, beta, w, 0);\n"
  "      // Multiply by PR'\n"
  "      for (c=0; c<ncol; ++c) x[c] = w[prinv[c]];\n"
  "    } else {\n"
  "      //PR' Q R PC x = b <-> x = PC' R \\ Q' PR b\n"
  "      // Multiply with PR\n"
  "      for (c=0; c<nrow_ext; ++c) w[c] = 0;\n"
  "      for (c=0; c<ncol; ++c) w[prinv[c]] = x[c];\n"
  "      // Multiply with Q'\n"
  "      casadi_qr_mv(sp_v, v, beta, w, 1);\n"
  "      //  Solve for R\n"
  "      casadi_qr_trs(sp_r, r, w, 0);\n"
  "      // Multiply with PC'\n"
  "      for (c=0; c<ncol; ++c) x[pc[c]] = w[c];\n"
  "    }\n"
  "    x += ncol;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qr_singular\"\n"
  "// Check if QR factorization corresponds to a singular matrix\n"
  "template<typename T1>\n"
  "casadi_int casadi_qr_singular(T1* rmin, casadi_int* irmin, const T1* nz_r,\n"
  "                             const casadi_int* sp_r, const casadi_int* pc, T1 eps) {\n"
  "  // Local variables\n"
  "  T1 rd, rd_min;\n"
  "  casadi_int ncol, c, nullity;\n"
  "  const casadi_int* r_colind;\n"
  "  // Nullity\n"
  "  nullity = 0;\n"
  "  // Extract sparsity\n"
  "  ncol = sp_r[1];\n"
  "  r_colind = sp_r + 2;\n"
  "  // Find the smallest diagonal entry\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    rd = fabs(nz_r[r_colind[c+1]-1]);\n"
  "    // Increase nullity if smaller than eps\n"
  "    if (rd<eps) nullity++;\n"
  "    // Check if smallest so far\n"
  "    if (c==0 || rd < rd_min) {\n"
  "      rd_min = rd;\n"
  "      if (rmin) *rmin = rd;\n"
  "      if (irmin) *irmin = pc[c];\n"
  "    }\n"
  "  }\n"
  "  // Return number of zero-ish eigenvalues\n"
  "  return nullity;\n"
  "}\n"
  "// SYMBOL \"qr_colcomb\"\n"
  "// Get a vector v such that A*v = 0 and |v| == 1\n"
  "template<typename T1>\n"
  "void casadi_qr_colcomb(T1* v, const T1* nz_r, const casadi_int* sp_r,\n"
  "                       const casadi_int* pc, T1 eps, casadi_int ind) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, r, c, k;\n"
  "  const casadi_int *r_colind, *r_row;\n"
  "  // Extract sparsity\n"
  "  ncol = sp_r[1];\n"
  "  r_colind = sp_r + 2;\n"
  "  r_row = r_colind + ncol + 1;\n"
  "  // Find the ind-th diagonal which is smaller than eps, overwrite ind with c\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    if (fabs(nz_r[r_colind[c+1]-1])<eps && 0==ind--) {\n"
  "      ind = c;\n"
  "      break;\n"
  "    }\n"
  "  }\n"
  "  // Reset w\n"
  "  casadi_fill(v, ncol, 0.);\n"
  "  v[pc[ind]] = 1.;\n"
  "  // Copy ind-th column to v\n"
  "  for (k=r_colind[ind]; k<r_colind[ind+1]-1; ++k) {\n"
  "    v[pc[r_row[k]]] = -nz_r[k];\n"
  "  }\n"
  "  // Backward substitution\n"
  "  for (c=ind-1; c>=0; --c) {\n"
  "    for (k=r_colind[c+1]-1; k>=r_colind[c]; --k) {\n"
  "      r=r_row[k];\n"
  "      if (r==c) {\n"
  "        if (fabs(nz_r[k])<eps) {\n"
  "          v[pc[r]] = 0;\n"
  "        } else {\n"
  "          v[pc[r]] /= nz_r[k];\n"
  "        }\n"
  "      } else {\n"
  "        v[pc[r]] -= nz_r[k]*v[pc[c]];\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  // Normalize v\n"
  "  casadi_scal(ncol, 1./sqrt(casadi_dot(ncol, v, v)), v);\n"
  "}\n";

const char* casadi_qp_str =
  "// NOLINT(legal/copyright)\n"
  "// C-REPLACE \"fmin\" \"casadi_fmin\"\n"
  "// C-REPLACE \"fmax\" \"casadi_fmax\"\n"
  "// C-REPLACE \"std::max\" \"casadi_max\"\n"
  "// SYMBOL \"qp_prob\"\n"
  "template<typename T1>\n"
  "struct casadi_qp_prob {\n"
  "  // Dimensions\n"
  "  casadi_int nx, na, nz;\n"
  "  // Smallest nonzero number\n"
  "  T1 dmin;\n"
  "  // Infinity\n"
  "  T1 inf;\n"
  "  // Dual to primal error\n"
  "  T1 du_to_pr;\n"
  "  // Print iterations\n"
  "  int print_iter;\n"
  "  // Sparsity patterns\n"
  "  const casadi_int *sp_a, *sp_h, *sp_at, *sp_kkt;\n"
  "  // Symbolic QR factorization\n"
  "  const casadi_int *prinv, *pc, *sp_v, *sp_r;\n"
  "};\n"
  "// C-REPLACE \"casadi_qp_prob<T1>\" \"struct casadi_qp_prob\"\n"
  "// SYMBOL \"qp_work\"\n"
  "template<typename T1>\n"
  "void casadi_qp_work(casadi_qp_prob<T1>* p, casadi_int* sz_iw, casadi_int* sz_w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;\n"
  "  // Get matrix number of nonzeros\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];\n"
  "  nnz_v = p->sp_v[2+p->sp_v[1]];\n"
  "  nnz_r = p->sp_r[2+p->sp_r[1]];\n"
  "  // Reset sz_w, sz_iw\n"
  "  *sz_w = *sz_iw = 0;\n"
  "  // Temporary work vectors\n"
  "  *sz_w = std::max(*sz_w, p->nz); // casadi_project, tau memory\n"
  "  *sz_iw = std::max(*sz_iw, p->nz); // casadi_trans, tau type, allzero\n"
  "  *sz_w = std::max(*sz_w, 2*p->nz); // casadi_qr\n"
  "  // Persistent work vectors\n"
  "  *sz_w += nnz_kkt; // kkt\n"
  "  *sz_w += p->nz; // z=[xk,gk]\n"
  "  *sz_w += p->nz; // lbz\n"
  "  *sz_w += p->nz; // ubz\n"
  "  *sz_w += p->nz; // lam\n"
  "  *sz_w += nnz_a; // trans(a)\n"
  "  *sz_w += p->nz; // dz\n"
  "  *sz_w += p->nz; // dlam\n"
  "  *sz_w += p->nx; // infeas\n"
  "  *sz_w += p->nx; // tinfeas\n"
  "  *sz_w += p->nz; // sens\n"
  "  *sz_iw += p->nz; // neverzero\n"
  "  *sz_iw += p->nz; // neverupper\n"
  "  *sz_iw += p->nz; // neverlower\n"
  "  *sz_iw += p->nz; // lincomb\n"
  "  *sz_w += std::max(nnz_v+nnz_r, nnz_kkt); // [v,r] or trans(kkt)\n"
  "  *sz_w += p->nz; // beta\n"
  "}\n"
  "// SYMBOL \"qp_data\"\n"
  "template<typename T1>\n"
  "struct casadi_qp_data {\n"
  "  // Problem structure\n"
  "  const casadi_qp_prob<T1>* prob;\n"
  "  // Cost\n"
  "  T1 f;\n"
  "  // QP data\n"
  "  const T1 *nz_a, *nz_h, *g;\n"
  "  // Vectors\n"
  "  T1 *z, *lbz, *ubz, *infeas, *tinfeas, *sens, *lam, *w, *dz, *dlam;\n"
  "  casadi_int *iw, *neverzero, *neverlower, *neverupper, *lincomb;\n"
  "  // Numeric QR factorization\n"
  "  T1 *nz_at, *nz_kkt, *beta, *nz_v, *nz_r;\n"
  "  // Message buffer\n"
  "  char msg[40];\n"
  "  // Stepsize\n"
  "  T1 tau;\n"
  "  // Singularity\n"
  "  casadi_int sing;\n"
  "  // Smallest diagonal value for the QR factorization\n"
  "  T1 mina;\n"
  "  casadi_int imina;\n"
  "  // Primal and dual error, corresponding index\n"
  "  T1 pr, du, epr, edu;\n"
  "  casadi_int ipr, idu;\n"
  "};\n"
  "// C-REPLACE \"casadi_qp_data<T1>\" \"struct casadi_qp_data\"\n"
  "// SYMBOL \"qp_init\"\n"
  "template<typename T1>\n"
  "void casadi_qp_init(casadi_qp_data<T1>* d, casadi_int* iw, T1* w) {\n"
  "  // Local variables\n"
  "  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Get matrix number of nonzeros\n"
  "  nnz_a = p->sp_a[2+p->sp_a[1]];\n"
  "  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];\n"
  "  nnz_v = p->sp_v[2+p->sp_v[1]];\n"
  "  nnz_r = p->sp_r[2+p->sp_r[1]];\n"
  "  d->nz_kkt = w; w += nnz_kkt;\n"
  "  d->z = w; w += p->nz;\n"
  "  d->lbz = w; w += p->nz;\n"
  "  d->ubz = w; w += p->nz;\n"
  "  d->lam = w; w += p->nz;\n"
  "  d->dz = w; w += p->nz;\n"
  "  d->dlam = w; w += p->nz;\n"
  "  d->nz_v = w; w += std::max(nnz_v+nnz_r, nnz_kkt);\n"
  "  d->nz_r = d->nz_v + nnz_v;\n"
  "  d->beta = w; w += p->nz;\n"
  "  d->nz_at = w; w += nnz_a;\n"
  "  d->infeas = w; w += p->nx;\n"
  "  d->tinfeas = w; w += p->nx;\n"
  "  d->sens = w; w += p->nz;\n"
  "  d->neverzero = iw; iw += p->nz;\n"
  "  d->neverupper = iw; iw += p->nz;\n"
  "  d->neverlower = iw; iw += p->nz;\n"
  "  d->lincomb = iw; iw += p->nz;\n"
  "  d->w = w;\n"
  "  d->iw = iw;\n"
  "}\n"
  "// SYMBOL \"qp_reset\"\n"
  "template<typename T1>\n"
  "int casadi_qp_reset(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Reset variables corresponding to previous iteration\n"
  "  d->msg[0] = '\\0';\n"
  "  d->tau = 0.;\n"
  "  d->sing = 0;\n"
  "  // Correct lam if needed, determine permitted signs\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Permitted signs for lam\n"
  "    d->neverzero[i] = d->lbz[i]==d->ubz[i];\n"
  "    d->neverupper[i] = isinf(d->ubz[i]);\n"
  "    d->neverlower[i] = isinf(d->lbz[i]);\n"
  "    if (d->neverzero[i] && d->neverupper[i] && d->neverlower[i]) return 1;\n"
  "    // Correct initial active set if required\n"
  "    if (d->neverzero[i] && d->lam[i]==0.) {\n"
  "      d->lam[i] = d->neverupper[i]\n"
  "                || d->z[i]-d->lbz[i] <= d->ubz[i]-d->z[i] ? -p->dmin : p->dmin;\n"
  "    } else if (d->neverupper[i] && d->lam[i]>0.) {\n"
  "      d->lam[i] = d->neverzero[i] ? -p->dmin : 0.;\n"
  "    } else if (d->neverlower[i] && d->lam[i]<0.) {\n"
  "      d->lam[i] = d->neverzero[i] ? p->dmin : 0.;\n"
  "    }\n"
  "  }\n"
  "  // Transpose A\n"
  "  casadi_trans(d->nz_a, p->sp_a, d->nz_at, p->sp_at, d->iw);\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_pr\"\n"
  "template<typename T1>\n"
  "void casadi_qp_pr(casadi_qp_data<T1>* d) {\n"
  "  // Calculate largest constraint violation\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  d->pr = 0;\n"
  "  d->ipr = -1;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->z[i] > d->ubz[i]+d->pr) {\n"
  "      d->pr = d->z[i]-d->ubz[i];\n"
  "      d->ipr = i;\n"
  "    } else if (d->z[i] < d->lbz[i]-d->pr) {\n"
  "      d->pr = d->lbz[i]-d->z[i];\n"
  "      d->ipr = i;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_du\"\n"
  "template<typename T1>\n"
  "void casadi_qp_du(casadi_qp_data<T1>* d) {\n"
  "  // Calculate largest constraint violation\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  d->du = 0;\n"
  "  d->idu = -1;\n"
  "  for (i=0; i<p->nx; ++i) {\n"
  "    if (d->infeas[i] > d->du) {\n"
  "      d->du = d->infeas[i];\n"
  "      d->idu = i;\n"
  "    } else if (d->infeas[i] < -d->du) {\n"
  "      d->du = -d->infeas[i];\n"
  "      d->idu = i;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_log\"\n"
  "template<typename T1>\n"
  "void casadi_qp_log(casadi_qp_data<T1>* d, const char* fmt, ...) {\n"
  "  va_list args;\n"
  "  va_start(args, fmt);\n"
  "  vsnprintf(d->msg, sizeof(d->msg), fmt, args);\n"
  "  va_end(args);\n"
  "}\n"
  "// SYMBOL \"qp_pr_index\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_pr_index(casadi_qp_data<T1>* d, casadi_int* sign) {\n"
  "  // Try to improve primal feasibility by adding a constraint\n"
  "  if (d->lam[d->ipr]==0.) {\n"
  "    // Add the most violating constraint\n"
  "    *sign = d->z[d->ipr]<d->lbz[d->ipr] ? -1 : 1;\n"
  "    casadi_qp_log(d, \"Added %lld to reduce |pr|\", d->ipr);\n"
  "    return d->ipr;\n"
  "  } else {\n"
  "    // Try to remove blocking constraints\n"
  "    return casadi_qp_du_index(d, sign, d->ipr);\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_du_check\"\n"
  "template<typename T1>\n"
  "T1 casadi_qp_du_check(casadi_qp_data<T1>* d, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  T1 new_du;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // AT sparsity\n"
  "  at_colind = p->sp_at + 2;\n"
  "  at_row = at_colind + p->na + 1;\n"
  "  // Maximum infeasibility from setting from setting lam[i]=0\n"
  "  if (i<p->nx) {\n"
  "    new_du = fabs(d->infeas[i]-d->lam[i]);\n"
  "  } else {\n"
  "    new_du = 0.;\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      new_du = fmax(new_du, fabs(d->infeas[at_row[k]]-d->nz_at[k]*d->lam[i]));\n"
  "    }\n"
  "  }\n"
  "  return new_du;\n"
  "}\n"
  "// SYMBOL \"qp_du_free\"\n"
  "template<typename T1>\n"
  "int casadi_qp_du_free(casadi_qp_data<T1>* d, casadi_int i, int upper) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // AT sparsity\n"
  "  at_colind = p->sp_at + 2;\n"
  "  at_row = at_colind + p->na + 1;\n"
  "  // Maximum infeasibility from setting from setting lam[i]=0\n"
  "  if (i<p->nx) {\n"
  "    if (upper) {\n"
  "      return d->infeas[i] + 1e-16 < d->edu;\n"
  "    } else {\n"
  "      return d->infeas[i] - 1e-16 > -d->edu;\n"
  "    }\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      if (d->nz_at[k]==0) continue;\n"
  "      if (d->nz_at[k]>0 ? upper : !upper) {\n"
  "        if (d->infeas[at_row[k]] + fabs(d->nz_at[k])*1e-16 >= d->edu) return 0;\n"
  "      } else {\n"
  "        if (d->infeas[at_row[k]] - fabs(d->nz_at[k])*1e-16 <= -d->edu) return 0;\n"
  "      }\n"
  "    }\n"
  "    return 1;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_du_index\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_du_index(casadi_qp_data<T1>* d, casadi_int* sign, casadi_int skip) {\n"
  "  // Try to improve dual feasibility by removing a constraint\n"
  "  // Local variables\n"
  "  casadi_int best_ind, i;\n"
  "  T1 best_sens;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Find the best lam[i] to make zero\n"
  "  best_ind = -1;\n"
  "  best_sens = -1;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Should the index be avoided?\n"
  "    if (i==skip) continue;\n"
  "    // Make sure that it's a constraint that can be removed\n"
  "    if (d->lam[i]==0 || d->neverzero[i]) continue;\n"
  "    // If variable influences du, make sure sign is right\n"
  "    if (d->lam[i]>0. ? d->sens[i]>0. : d->sens[i]<0.) continue;\n"
  "    // Skip if maximum infeasibility increases\n"
  "    if (casadi_qp_du_check(d, i)>d->du) continue;\n"
  "    // Check if best so far\n"
  "    if (fabs(d->sens[i])>best_sens) {\n"
  "      best_sens = fabs(d->sens[i]);\n"
  "      best_ind = i;\n"
  "    }\n"
  "  }\n"
  "  // Accept, if any\n"
  "  if (best_ind>=0) {\n"
  "    *sign = 0;\n"
  "    casadi_qp_log(d, \"Removed %lld to reduce |du|\", best_ind);\n"
  "    return best_ind;\n"
  "  } else {\n"
  "    return -1;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_kkt\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i, k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row,\n"
  "                   *kkt_colind, *kkt_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a+2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h+2) + p->nx + 1;\n"
  "  kkt_row = (kkt_colind = p->sp_kkt+2) + p->nz + 1;\n"
  "  // Reset w to zero\n"
  "  casadi_fill(d->w, p->nz, 0.);\n"
  "  // Loop over rows of the (transposed) KKT\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Copy row of KKT to w\n"
  "    if (i<p->nx) {\n"
  "      if (d->lam[i]==0) {\n"
  "        for (k=h_colind[i]; k<h_colind[i+1]; ++k) d->w[h_row[k]] = d->nz_h[k];\n"
  "        for (k=a_colind[i]; k<a_colind[i+1]; ++k) d->w[p->nx+a_row[k]] = d->nz_a[k];\n"
  "      } else {\n"
  "        d->w[i] = 1.;\n"
  "      }\n"
  "    } else {\n"
  "      if (d->lam[i]==0) {\n"
  "        d->w[i] = -1.;\n"
  "      } else {\n"
  "        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "          d->w[at_row[k]] = d->nz_at[k];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Copy row to KKT, zero out w\n"
  "    for (k=kkt_colind[i]; k<kkt_colind[i+1]; ++k) {\n"
  "      d->nz_kkt[k] = d->w[kkt_row[k]];\n"
  "      d->w[kkt_row[k]] = 0;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_kkt_vector\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt_vector(casadi_qp_data<T1>* d, T1* kkt_i, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a+2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h+2) + p->nx + 1;\n"
  "  // Reset kkt_i to zero\n"
  "  casadi_fill(kkt_i, p->nz, 0.);\n"
  "  // Copy sparse entries\n"
  "  if (i<p->nx) {\n"
  "    for (k=h_colind[i]; k<h_colind[i+1]; ++k) kkt_i[h_row[k]] = d->nz_h[k];\n"
  "    for (k=a_colind[i]; k<a_colind[i+1]; ++k) kkt_i[p->nx+a_row[k]] = d->nz_a[k];\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      kkt_i[at_row[k]] = -d->nz_at[k];\n"
  "    }\n"
  "  }\n"
  "  // Add diagonal entry\n"
  "  kkt_i[i] -= 1.;\n"
  "}\n"
  "// SYMBOL \"qp_kkt_dot\"\n"
  "template<typename T1>\n"
  "T1 casadi_qp_kkt_dot(casadi_qp_data<T1>* d, const T1* v, casadi_int i) {\n"
  "  // Local variables\n"
  "  casadi_int k;\n"
  "  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;\n"
  "  T1 r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  a_row = (a_colind = p->sp_a+2) + p->nx + 1;\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  h_row = (h_colind = p->sp_h+2) + p->nx + 1;\n"
  "  // Scalar product with the diagonal\n"
  "  r = v[i];\n"
  "  // Scalar product with the sparse entries\n"
  "  if (i<p->nx) {\n"
  "    for (k=h_colind[i]; k<h_colind[i+1]; ++k) r -= v[h_row[k]] * d->nz_h[k];\n"
  "    for (k=a_colind[i]; k<a_colind[i+1]; ++k) r -= v[p->nx+a_row[k]] * d->nz_a[k];\n"
  "  } else {\n"
  "    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "      r += v[at_row[k]] * d->nz_at[k];\n"
  "    }\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "// SYMBOL \"qp_kkt_residual\"\n"
  "template<typename T1>\n"
  "void casadi_qp_kkt_residual(casadi_qp_data<T1>* d, T1* r) {\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->lam[i]>0.) {\n"
  "      r[i] = d->ubz[i]-d->z[i];\n"
  "    } else if (d->lam[i]<0.) {\n"
  "      r[i] = d->lbz[i]-d->z[i];\n"
  "    } else if (i<p->nx) {\n"
  "      r[i] = d->lam[i]-d->infeas[i];\n"
  "    } else {\n"
  "      r[i] = d->lam[i];\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_zero_blocking\"\n"
  "template<typename T1>\n"
  "int casadi_qp_zero_blocking(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->dz[i]<0 && d->z[i]<=d->lbz[i]-d->epr) {\n"
  "      return 1;\n"
  "    } else if (d->dz[i]>0 && d->z[i]>=d->ubz[i]+d->epr) {\n"
  "      return 1;\n"
  "    }\n"
  "  }\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_primal_blocking\"\n"
  "template<typename T1>\n"
  "void casadi_qp_primal_blocking(casadi_qp_data<T1>* d,\n"
  "                               casadi_int* index, casadi_int* sign) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 trial_z;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Check if violation with tau=0 and not improving\n"
  "  if (casadi_qp_zero_blocking(d)) {\n"
  "    d->tau = 0.;\n"
  "    return;\n"
  "  }\n"
  "  // Loop over all primal variables\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->dz[i]==0.) continue; // Skip zero steps\n"
  "    // Trial primal step\n"
  "    trial_z=d->z[i] + d->tau*d->dz[i];\n"
  "    if (d->dz[i]<0 && trial_z<d->lbz[i]-d->epr) {\n"
  "      // Trial would increase maximum infeasibility\n"
  "      d->tau = (d->lbz[i]-d->epr-d->z[i])/d->dz[i];\n"
  "      if (index) *index = d->lam[i]<0. ? -1 : i;\n"
  "      if (sign) *sign = -1;\n"
  "      casadi_qp_log(d, \"Enforcing lbz[%lld]\", i);\n"
  "    } else if (d->dz[i]>0 && trial_z>d->ubz[i]+d->epr) {\n"
  "      // Trial would increase maximum infeasibility\n"
  "      d->tau = (d->ubz[i]+d->epr-d->z[i])/d->dz[i];\n"
  "      if (index) *index = d->lam[i]>0. ? -1 : i;\n"
  "      if (sign) *sign = 1;\n"
  "      casadi_qp_log(d, \"Enforcing ubz[%lld]\", i);\n"
  "    }\n"
  "    if (d->tau<=0) return;\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_dual_breakpoints\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_dual_breakpoints(casadi_qp_data<T1>* d, T1* tau_list,\n"
  "                                      casadi_int* ind_list, T1 tau) {\n"
  "  // Local variables\n"
  "  casadi_int i, n_tau, loc, next_ind, tmp_ind, j;\n"
  "  T1 trial_lam, new_tau, next_tau, tmp_tau;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Dual feasibility is piecewise linear. Start with one interval [0,tau]:\n"
  "  tau_list[0] = tau;\n"
  "  ind_list[0] = -1; // no associated index\n"
  "  n_tau = 1;\n"
  "  // Find the taus corresponding to lam crossing zero and insert into list\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    if (d->dlam[i]==0.) continue; // Skip zero steps\n"
  "    if (d->lam[i]==0.) continue; // Skip inactive constraints\n"
  "    // Trial dual step\n"
  "    trial_lam = d->lam[i] + tau*d->dlam[i];\n"
  "    // Skip if no sign change\n"
  "    if (d->lam[i]>0 ? trial_lam>=0 : trial_lam<=0) continue;\n"
  "    // Location of the sign change\n"
  "    new_tau = -d->lam[i]/d->dlam[i];\n"
  "    // Where to insert the w[i]\n"
  "    for (loc=0; loc<n_tau-1; ++loc) {\n"
  "      if (new_tau<tau_list[loc]) break;\n"
  "    }\n"
  "    // Insert element\n"
  "    n_tau++;\n"
  "    next_tau=new_tau;\n"
  "    next_ind=i;\n"
  "    for (j=loc; j<n_tau; ++j) {\n"
  "      tmp_tau = tau_list[j];\n"
  "      tau_list[j] = next_tau;\n"
  "      next_tau = tmp_tau;\n"
  "      tmp_ind = ind_list[j];\n"
  "      ind_list[j] = next_ind;\n"
  "      next_ind = tmp_ind;\n"
  "    }\n"
  "  }\n"
  "  return n_tau;\n"
  "}\n"
  "// SYMBOL \"qp_dual_blocking\"\n"
  "template<typename T1>\n"
  "casadi_int casadi_qp_dual_blocking(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i, n_tau, j, k, du_index;\n"
  "  T1 tau_k, dtau, new_infeas, tau1;\n"
  "  const casadi_int *at_colind, *at_row;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Extract sparsities\n"
  "  at_row = (at_colind = p->sp_at+2) + p->na + 1;\n"
  "  // Dual feasibility is piecewise linear in tau. Get the intervals:\n"
  "  n_tau = casadi_qp_dual_breakpoints(d, d->w, d->iw, d->tau);\n"
  "  // No dual blocking yet\n"
  "  du_index = -1;\n"
  "  // How long step can we take without exceeding e?\n"
  "  tau_k = 0.;\n"
  "  for (j=0; j<n_tau; ++j) {\n"
  "    // Distance to the next tau (may be zero)\n"
  "    dtau = d->w[j] - tau_k;\n"
  "    // Check if maximum dual infeasibilty gets exceeded\n"
  "    for (k=0; k<p->nx; ++k) {\n"
  "      new_infeas = d->infeas[k]+dtau*d->tinfeas[k];\n"
  "      if (fabs(new_infeas)>d->edu) {\n"
  "        tau1 = fmax(0., tau_k + ((new_infeas>0 ? d->edu : -d->edu)-d->infeas[k])/d->tinfeas[k]);\n"
  "        if (tau1 < d->tau) {\n"
  "          // Smallest tau found so far\n"
  "          d->tau = tau1;\n"
  "          du_index = k;\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Update infeasibility\n"
  "    casadi_axpy(p->nx, fmin(d->tau - tau_k, dtau), d->tinfeas, d->infeas);\n"
  "    // Stop here if dual blocking constraint\n"
  "    if (du_index>=0) return du_index;\n"
  "    // Continue to the next tau\n"
  "    tau_k = d->w[j];\n"
  "    // Get component, break if last\n"
  "    i = d->iw[j];\n"
  "    if (i<0) break;\n"
  "    // Update sign or tinfeas\n"
  "    if (!d->neverzero[i]) {\n"
  "      // lam becomes zero, update the infeasibility tangent\n"
  "      if (i<p->nx) {\n"
  "        // Set a lam_x to zero\n"
  "        d->tinfeas[i] -= d->dlam[i];\n"
  "      } else {\n"
  "        // Set a lam_a to zero\n"
  "        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {\n"
  "          d->tinfeas[at_row[k]] -= d->nz_at[k]*d->dlam[i];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return du_index;\n"
  "}\n"
  "// SYMBOL \"qp_take_step\"\n"
  "template<typename T1>\n"
  "void casadi_qp_take_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Get current sign\n"
  "  for (i=0; i<p->nz; ++i) d->iw[i] = d->lam[i]>0. ? 1 : d->lam[i]<0 ? -1 : 0;\n"
  "  // Take primal-dual step\n"
  "  casadi_axpy(p->nz, d->tau, d->dz, d->z);\n"
  "  casadi_axpy(p->nz, d->tau, d->dlam, d->lam);\n"
  "  // Update sign\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Allow sign changes for certain components\n"
  "    if (d->neverzero[i] && (d->iw[i]<0 ? d->lam[i]>0 : d->lam[i]<0)) {\n"
  "      d->iw[i]=-d->iw[i];\n"
  "    }\n"
  "    // Ensure correct sign\n"
  "    switch (d->iw[i]) {\n"
  "      case -1: d->lam[i] = fmin(d->lam[i], -p->dmin); break;\n"
  "      case  1: d->lam[i] = fmax(d->lam[i],  p->dmin); break;\n"
  "      case  0: d->lam[i] = 0.; break;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "// SYMBOL \"qp_flip_check\"\n"
  "template<typename T1>\n"
  "int casadi_qp_flip_check(casadi_qp_data<T1>* d, casadi_int index, casadi_int sign,\n"
  "                         casadi_int* r_index, casadi_int* r_sign) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 best, test;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate the difference between unenforced and enforced column index\n"
  "  casadi_qp_kkt_vector(d, d->dz, index);\n"
  "  // Calculate the difference between old and new column index\n"
  "  if (sign==0) casadi_scal(p->nz, -1., d->dz);\n"
  "  // Make a copy before it's overwritten\n"
  "  casadi_copy(d->dz, p->nz, d->dlam);\n"
  "  // Try to find a linear combination of the new columns\n"
  "  casadi_qr_solve(d->dz, 1, 0, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "                  p->prinv, p->pc, d->w);\n"
  "  // If dz[index]!=1, new columns must be linearly independent\n"
  "  if (fabs(d->dz[index]-1.)>=1e-12) return 0;\n"
  "  // Similarly, find a linear combination of the rows\n"
  "  casadi_qr_solve(d->dlam, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "                  p->prinv, p->pc, d->w);\n"
  "  // If dlam[index]!=1, new rows must be linearly independent (due to numerics?)\n"
  "  if (fabs(d->dlam[index]-1.)>=1e-12) return 0;\n"
  "  // Find best constraint we can flip, if any\n"
  "  *r_index=-1;\n"
  "  *r_sign=0;\n"
  "  best = inf;\n"
  "  for (i=0; i<p->nz; ++i) {\n"
  "    // Can't be the same\n"
  "    if (i==index) continue;\n"
  "    // Make sure constraint is flippable\n"
  "    if (d->lam[i]==0 ? d->neverlower[i] && d->neverupper[i] : d->neverzero[i]) continue;\n"
  "    // If dz[i]==0, column i is not part of the linear combination\n"
  "    if (fabs(d->dz[i])<1e-12) continue;\n"
  "    // If dot(dlam, kkt_diff(i))==0, rank won't increase\n"
  "    if (fabs(casadi_qp_kkt_dot(d, d->dlam, i))<1e-12) continue;\n"
  "    // Never drop a violated constraint\n"
  "    if (d->lam[i]>0 && d->z[i]>d->ubz[i]) continue;\n"
  "    if (d->lam[i]<0 && d->z[i]<d->lbz[i]) continue;\n"
  "    // Check if best so far\n"
  "    if (d->lam[i]==0) {\n"
  "      // Check sensitivity for positive lam[i], larger is better\n"
  "      if (!d->neverupper[i] && (test=-d->sens[i]) < best) {\n"
  "        best = test;\n"
  "        *r_index = i;\n"
  "        *r_sign = 1;\n"
  "      }\n"
  "      // Check sensitivity for negative lam[i], smaller is better\n"
  "      if (!d->neverlower[i] && (test=d->sens[i]) < best) {\n"
  "        best = test;\n"
  "        *r_index = i;\n"
  "        *r_sign = -1;\n"
  "      }\n"
  "    } else {\n"
  "      // Check new dual error for affected subset from setting lam[i]=0\n"
  "      if ((test=casadi_qp_du_check(d, i)) < best && test<d->edu) {\n"
  "        best = test;\n"
  "        *r_index = i;\n"
  "        *r_sign = 0;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  // Enforcing will lead to (possibly recoverable) singularity\n"
  "  return 1;\n"
  "}\n"
  "// SYMBOL \"qp_factorize\"\n"
  "template<typename T1>\n"
  "void casadi_qp_factorize(casadi_qp_data<T1>* d) {\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Construct the KKT matrix\n"
  "  casadi_qp_kkt(d);\n"
  "  // QR factorization\n"
  "  casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r,\n"
  "            d->nz_r, d->beta, p->prinv, p->pc);\n"
  "  // Check singularity\n"
  "  d->sing = casadi_qr_singular(&d->mina, &d->imina, d->nz_r, p->sp_r, p->pc, 1e-12);\n"
  "}\n"
  "// SYMBOL \"qp_expand_step\"\n"
  "template<typename T1>\n"
  "void casadi_qp_expand_step(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate change in Lagrangian gradient\n"
  "  casadi_fill(d->dlam, p->nx, 0.);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->dz, d->dlam, 0); // gradient of the objective\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dz+p->nx, d->dlam, 1); // gradient of the Lagrangian\n"
  "  // Step in lam[:nx]\n"
  "  casadi_scal(p->nx, -1., d->dlam);\n"
  "  // For inactive constraints, lam(x) step is zero\n"
  "  for (i=0; i<p->nx; ++i) if (d->lam[i]==0.) d->dlam[i] = 0.;\n"
  "  // Step in lam[nx:]\n"
  "  casadi_copy(d->dz+p->nx, p->na, d->dlam+p->nx);\n"
  "  // Step in z[nx:]\n"
  "  casadi_fill(d->dz+p->nx, p->na, 0.);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dz, d->dz+p->nx, 0);\n"
  "  // Avoid steps that are nonzero due to numerics\n"
  "  for (i=0; i<p->nz; ++i) if (fabs(d->dz[i])<1e-14) d->dz[i] = 0.;\n"
  "  // Tangent of the dual infeasibility at tau=0\n"
  "  casadi_fill(d->tinfeas, p->nx, 0.);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->dz, d->tinfeas, 0);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->dlam+p->nx, d->tinfeas, 1);\n"
  "  casadi_axpy(p->nx, 1., d->dlam, d->tinfeas);\n"
  "}\n"
  "// SYMBOL \"qp_singular_step\"\n"
  "// C-REPLACE \"static_cast<T1*>(0)\" \"0\"\n"
  "template<typename T1>\n"
  "int casadi_qp_singular_step(casadi_qp_data<T1>* d, casadi_int* r_index, casadi_int* r_sign) {\n"
  "  // Local variables\n"
  "  T1 tau_test, tau;\n"
  "  casadi_int nnz_kkt, nk, k, i;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Find the columns that take part in any linear combination\n"
  "  for (i=0; i<p->nz; ++i) d->lincomb[i]=0;\n"
  "  for (k=0; k<d->sing; ++k) {\n"
  "    casadi_qr_colcomb(d->w, d->nz_r, p->sp_r, p->pc, 1e-12, k);\n"
  "    for (i=0; i<p->nz; ++i) if (fabs(d->w[i])>=1e-12) d->lincomb[i]++;\n"
  "  }\n"
  "  // QR factorization of the transpose\n"
  "  casadi_trans(d->nz_kkt, p->sp_kkt, d->nz_v, p->sp_kkt, d->iw);\n"
  "  nnz_kkt = p->sp_kkt[2+p->nz]; // kkt_colind[nz]\n"
  "  casadi_copy(d->nz_v, nnz_kkt, d->nz_kkt);\n"
  "  casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r, d->nz_r,\n"
  "            d->beta, p->prinv, p->pc);\n"
  "  // Best flip\n"
  "  tau = p->inf;\n"
  "  // For all nullspace vectors\n"
  "  nk = casadi_qr_singular(static_cast<T1*>(0), 0, d->nz_r, p->sp_r, p->pc, 1e-12);\n"
  "  for (k=0; k<nk; ++k) {\n"
  "    // Local variables\n"
  "    T1 tau_min, tau_max;\n"
  "    // Get a linear combination of the rows in kkt\n"
  "    casadi_qr_colcomb(d->w, d->nz_r, p->sp_r, p->pc, 1e-12, k);\n"
  "    // Which constraints can be flipped in order to increase rank?\n"
  "    for (i=0; i<p->nz; ++i) {\n"
  "      d->iw[i] = d->lincomb[i] && fabs(casadi_qp_kkt_dot(d, d->w, i))>=1e-12;\n"
  "    }\n"
  "    // Calculate step, dz and dlam\n"
  "    casadi_copy(d->w, p->nz, d->dz);\n"
  "    casadi_qp_expand_step(d);\n"
  "    // Check if primal or dual error is dominating\n"
  "    tau_min = -p->inf;\n"
  "    tau_max = p->inf;\n"
  "    if (p->du_to_pr*d->pr >= d->du) {\n"
  "      // Make sure that primal error doesn't increase in the search direction\n"
  "      if (d->z[d->ipr]>d->ubz[d->ipr]) {\n"
  "        // Upper bound violated, make sure volation doesn't increase\n"
  "        if (d->dz[d->ipr]>0) {\n"
  "          tau_max = 0;\n"
  "        } else if (d->dz[d->ipr]<0) {\n"
  "          tau_min = 0;\n"
  "        }\n"
  "        // If enforced, do not allow multiplier to cross zero\n"
  "        if (d->lam[d->ipr]>0) {\n"
  "          d->iw[d->ipr] = 0;\n"
  "          if (d->dlam[d->ipr]>0) {\n"
  "            tau_min = -d->lam[d->ipr]/d->dlam[d->ipr];\n"
  "          } else if (d->dlam[d->ipr]<0) {\n"
  "            tau_max = -d->lam[d->ipr]/d->dlam[d->ipr];\n"
  "          }\n"
  "        }\n"
  "      } else {\n"
  "        // Lower bound violated, make sure volation doesn't increase\n"
  "        if (d->dz[d->ipr]>0) {\n"
  "          tau_min = 0;\n"
  "        } else if (d->dz[d->ipr]<0) {\n"
  "          tau_max = 0;\n"
  "        }\n"
  "        // If enforced, do not allow multiplier to cross zero\n"
  "        if (d->lam[d->ipr]<0) {\n"
  "          d->iw[d->ipr] = 0;\n"
  "          if (d->dlam[d->ipr]<0) {\n"
  "            tau_min = -d->lam[d->ipr]/d->dlam[d->ipr];\n"
  "          } else if (d->dlam[d->ipr]>0) {\n"
  "            tau_max = -d->lam[d->ipr]/d->dlam[d->ipr];\n"
  "          }\n"
  "        }\n"
  "      }\n"
  "    } else {\n"
  "      // Make sure dual infeasibility doesn't increase in the search direction\n"
  "      if (d->infeas[d->idu]>0) {\n"
  "        if (d->tinfeas[d->idu]>0) tau_max = 0;\n"
  "      } else {\n"
  "        if (d->tinfeas[d->idu]<0) tau_min = 0;\n"
  "      }\n"
  "    }\n"
  "    // Can we enforce a lower bound?\n"
  "    for (i=0; i<p->nz; ++i) {\n"
  "      if (d->iw[i] && d->lam[i]==0. && !d->neverlower[i] && fabs(d->dz[i])>=1e-12) {\n"
  "        if (!casadi_qp_du_free(d, i, 0)) continue;\n"
  "        tau_test = (d->lbz[i]-d->z[i])/d->dz[i];\n"
  "        if (tau_test<tau_min || tau_test>tau_max) continue;\n"
  "        if (fabs(tau_test)<fabs(tau)) {\n"
  "          tau = tau_test;\n"
  "          *r_index = i;\n"
  "          *r_sign = -1;\n"
  "          casadi_qp_log(d, \"Enforced lbz[%lld] for regularity\", i);\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Can we enforce an upper bound?\n"
  "    for (i=0; i<p->nz; ++i) {\n"
  "      if (d->iw[i] && d->lam[i]==0. && !d->neverupper[i] && fabs(d->dz[i])>=1e-12) {\n"
  "        if (!casadi_qp_du_free(d, i, 1)) continue;\n"
  "        tau_test = (d->ubz[i]-d->z[i])/d->dz[i];\n"
  "        if (tau_test<tau_min || tau_test>tau_max) continue;\n"
  "        if (fabs(tau_test)<fabs(tau)) {\n"
  "          tau = tau_test;\n"
  "          *r_index = i;\n"
  "          *r_sign = 1;\n"
  "          casadi_qp_log(d, \"Enforced ubz[%lld] for regularity\", i);\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Can we drop a constraint?\n"
  "    for (i=0; i<p->nz; ++i) {\n"
  "      if (d->iw[i] && d->lam[i]!=0. && !d->neverzero[i] && fabs(d->dlam[i])>=1e-12) {\n"
  "        tau_test = -d->lam[i]/d->dlam[i]; // scaling factor since lam can be close do DMIN\n"
  "        if (tau_test<tau_min || tau_test>tau_max) continue;\n"
  "        // Check if best so far\n"
  "        if (fabs(tau_test)<fabs(tau)) {\n"
  "          tau = tau_test;\n"
  "          *r_index = i;\n"
  "          *r_sign = 0;\n"
  "          casadi_qp_log(d, \"Dropped %s[%lld] for regularity\", d->lam[i]>0 ? \"lbz\" : \"ubz\", i);\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "    // Break at first possible direction\n"
  "    if (*r_index>=0) break;\n"
  "  }\n"
  "  // Can we restore feasibility?\n"
  "  if (*r_index<0) return 1;\n"
  "  // Scale step so that that tau=1 corresponds to a full step\n"
  "  casadi_scal(p->nz, tau, d->dz);\n"
  "  casadi_scal(p->nz, tau, d->dlam);\n"
  "  casadi_scal(p->nx, tau, d->tinfeas);\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_calc_step\"\n"
  "template<typename T1>\n"
  "int casadi_qp_calc_step(casadi_qp_data<T1>* d, casadi_int* r_index, casadi_int* r_sign) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Reset returns\n"
  "  *r_index = -1;\n"
  "  *r_sign = 0;\n"
  "  // Handle singularity\n"
  "  if (d->sing) return casadi_qp_singular_step(d, r_index, r_sign);\n"
  "  // Negative KKT residual\n"
  "  casadi_qp_kkt_residual(d, d->dz);\n"
  "  // Solve to get step in z[:nx] and lam[nx:]\n"
  "  casadi_qr_solve(d->dz, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,\n"
  "                  p->prinv, p->pc, d->w);\n"
  "  // Have step in dz[:nx] and dlam[nx:]. Calculate complete dz and dlam\n"
  "  casadi_qp_expand_step(d);\n"
  "  // Successful return\n"
  "  return 0;\n"
  "}\n"
  "// SYMBOL \"qp_calc_dependent\"\n"
  "template<typename T1>\n"
  "void casadi_qp_calc_dependent(casadi_qp_data<T1>* d) {\n"
  "  // Local variables\n"
  "  casadi_int i;\n"
  "  T1 r;\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Calculate f\n"
  "  d->f = casadi_bilin(d->nz_h, p->sp_h, d->z, d->z)/2.\n"
  "       + casadi_dot(p->nx, d->z, d->g);\n"
  "  // Calculate z[nx:]\n"
  "  casadi_fill(d->z+p->nx, p->na, 0.);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->z, d->z+p->nx, 0);\n"
  "  // Calculate gradient of the Lagrangian\n"
  "  casadi_copy(d->g, p->nx, d->infeas);\n"
  "  casadi_mv(d->nz_h, p->sp_h, d->z, d->infeas, 0);\n"
  "  casadi_mv(d->nz_a, p->sp_a, d->lam+p->nx, d->infeas, 1);\n"
  "  // Calculate lam[:nx] without changing the sign accidentally, dual infeasibility\n"
  "  for (i=0; i<p->nx; ++i) {\n"
  "    // No change if zero\n"
  "    if (d->lam[i]==0) continue;\n"
  "    // lam[i] with no sign restrictions\n"
  "    r = -d->infeas[i];\n"
  "    if (d->lam[i]>0) {\n"
  "      if (d->neverzero[i] && !d->neverlower[i]) {\n"
  "        d->lam[i] = r==0 ? p->dmin : r; // keep sign if r==0\n"
  "      } else {\n"
  "        d->lam[i] = fmax(r, p->dmin); // no sign change\n"
  "      }\n"
  "    } else {\n"
  "      if (d->neverzero[i] && !d->neverupper[i]) {\n"
  "        d->lam[i] = r==0 ? -p->dmin : r; // keep sign if r==0\n"
  "      } else {\n"
  "        d->lam[i] = fmin(r, -p->dmin); // no sign change\n"
  "      }\n"
  "    }\n"
  "    // Update dual infeasibility\n"
  "    d->infeas[i] += d->lam[i];\n"
  "  }\n"
  "  // Calculate primal and dual error\n"
  "  casadi_qp_pr(d);\n"
  "  casadi_qp_du(d);\n"
  "  // Acceptable primal and dual error\n"
  "  d->epr = fmax(d->pr, 0.5*d->du/p->du_to_pr);\n"
  "  d->edu = fmax(d->du, 0.5*p->du_to_pr*d->pr);\n"
  "  // Sensitivity in decreasing |du|\n"
  "  casadi_fill(d->sens, p->nz, 0.);\n"
  "  if (d->idu>=0) {\n"
  "    d->sens[d->idu] = d->infeas[d->idu]>0 ? -1. : 1.;\n"
  "    casadi_mv(d->nz_a, p->sp_a, d->sens, d->sens+p->nx, 0);\n"
  "  }\n"
  "}\n"
  "template<typename T1>\n"
  "void casadi_qp_linesearch(casadi_qp_data<T1>* d, casadi_int* index, casadi_int* sign) {\n"
  "  // Start with a full step and no active set change\n"
  "  *sign=0;\n"
  "  *index=-1;\n"
  "  d->tau = 1.;\n"
  "  // Find largest possible step without exceeding acceptable |pr|\n"
  "  casadi_qp_primal_blocking(d, index, sign);\n"
  "  // Find largest possible step without exceeding acceptable |du|\n"
  "  if (casadi_qp_dual_blocking(d)>=0) {\n"
  "    *index = -1;\n"
  "    *sign=0;\n"
  "  }\n"
  "  // Take primal-dual step, avoiding accidental sign changes for lam\n"
  "  casadi_qp_take_step(d);\n"
  "}\n"
  "template<typename T1>\n"
  "void casadi_qp_flip(casadi_qp_data<T1>* d, casadi_int *index, casadi_int *sign,\n"
  "                                          casadi_int r_index, casadi_int r_sign) {\n"
  "  // Local variables\n"
  "  const casadi_qp_prob<T1>* p = d->prob;\n"
  "  // Try to restore regularity if possible\n"
  "  if (r_index>=0 && (r_sign!=0 || casadi_qp_du_check(d, r_index)<=d->edu)) {\n"
  "    *index = r_index;\n"
  "    *sign = r_sign;\n"
  "    casadi_qp_log(d, \"%lld->%lld for regularity\", *index, *sign);\n"
  "  }  else if (r_index>=0 && d->tau>1e-16) {\n"
  "    // Allow another regularity step\n"
  "    *index=-2;\n"
  "  }\n"
  "  // Improve primal or dual feasibility\n"
  "  if (*index==-1 && (d->ipr>=0 || d->idu>=0)) {\n"
  "    if (p->du_to_pr*d->pr >= d->du) {\n"
  "      // Try to improve primal feasibility\n"
  "      *index = casadi_qp_pr_index(d, sign);\n"
  "    } else {\n"
  "      // Try to improve dual feasibility\n"
  "      *index = casadi_qp_du_index(d, sign, -1);\n"
  "    }\n"
  "  }\n"
  "  // If a constraint was added\n"
  "  if (*index>=0) {\n"
  "    // Try to maintain non-singularity if possible\n"
  "    if (!d->sing && casadi_qp_flip_check(d, *index, *sign, &r_index, &r_sign)) {\n"
  "      if (r_index>=0) {\n"
  "        // Also flip r_index to avoid singularity\n"
  "        d->lam[r_index] = r_sign==0 ? 0 : r_sign>0 ? p->dmin : -p->dmin;\n"
  "        casadi_qp_log(d, \"%lld->%lld, %lld->%lld\", *index, *sign, r_index, r_sign);\n"
  "      } else if (*sign==0 && d->sens[*index]==0.) {\n"
  "        // Abort: Not worth it to sacrifice regularity\n"
  "        *index = -1;\n"
  "        return;\n"
  "      }\n"
  "    }\n"
  "    d->lam[*index] = *sign==0 ? 0 : *sign>0 ? p->dmin : -p->dmin;\n"
  "    // Recalculate primal and dual infeasibility\n"
  "    casadi_qp_calc_dependent(d);\n"
  "    // Reset index\n"
  "    *index=-2;\n"
  "  }\n"
  "}\n";

const char* casadi_bfgs_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"bfgs\"\n"
  "// BFGS update\n"
  "template<typename T1>\n"
  "void casadi_bfgs(const casadi_int* sp_h, T1* h, const T1* dx,\n"
  "                 const T1* glag, const T1* glag_old, T1* w) {\n"
  "  // Local variables\n"
  "  casadi_int nx;\n"
  "  T1 *yk, *qk, dxBkdx, omega, theta, phi;\n"
  "  // Dimension\n"
  "  nx = sp_h[0];\n"
  "  // Work vectors\n"
  "  yk = w; w += nx;\n"
  "  qk = w; w += nx;\n"
  "  // yk = glag - glag_old\n"
  "  casadi_copy(glag, nx, yk);\n"
  "  casadi_axpy(nx, -1., glag_old, yk);\n"
  "  // qk = H*dx\n"
  "  casadi_fill(qk, nx, 0.);\n"
  "  casadi_mv(h, sp_h, dx, qk, 0);\n"
  "  // Calculating theta\n"
  "  dxBkdx = casadi_dot(nx, dx, qk);\n"
  "  // C-REPLACE \"if_else\" \"casadi_if_else\"\n"
  "  omega = if_else(casadi_dot(nx, yk, dx) < 0.2 * casadi_dot(nx, dx, qk),\n"
  "                  0.8 * dxBkdx / (dxBkdx - casadi_dot(nx, dx, yk)), 1);\n"
  "  // yk = omega * yk + (1 - omega) * qk;\n"
  "  casadi_scal(nx, omega, yk);\n"
  "  casadi_axpy(nx, 1 - omega, qk, yk);\n"
  "  theta = 1. / casadi_dot(nx, dx, yk);\n"
  "  phi = 1. / casadi_dot(nx, qk, dx);\n"
  "  // Update H\n"
  "  casadi_rank1(h, sp_h, theta, yk, yk);\n"
  "  casadi_rank1(h, sp_h, -phi, qk, qk);\n"
  "}\n"
  "// SYMBOL \"bfgs_reset\"\n"
  "// Removes off-diagonal entries\n"
  "template<typename T1>\n"
  "void casadi_bfgs_reset(const casadi_int* sp_h, T1* h) {\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (c!=row[k]) h[k] = 0;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_regularize_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"lb_eig\"\n"
  "// Use Gershgorin to finds upper and lower bounds on the eigenvalues\n"
  "template<typename T1>\n"
  "double casadi_lb_eig(const casadi_int* sp_h, const T1* h) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, k;\n"
  "  T1 center, radius;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Return value\n"
  "  T1 lb_eig = 0;\n"
  "  // Get sparsity\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    // Calculate Gershgorin discs\n"
  "    center = 0;\n"
  "    radius = 0;\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (row[k]==c) {\n"
  "        center = h[k];\n"
  "      } else {\n"
  "        radius += std::fabs(h[k]);\n"
  "      }\n"
  "    }\n"
  "    // Update the eigenvalue estimates\n"
  "    if (c==0) {\n"
  "      lb_eig = center - radius;\n"
  "    } else {\n"
  "      lb_eig = std::fmin(lb_eig, center - radius);\n"
  "    }\n"
  "  }\n"
  "  return lb_eig;\n"
  "}\n"
  "// SYMBOL \"regularize\"\n"
  "// Add a multiple of the identity matrix to the diagonal\n"
  "template<typename T1>\n"
  "void casadi_regularize(const casadi_int* sp_h, T1* h, T1 reg) {\n"
  "  // Local variables\n"
  "  casadi_int ncol, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  // Get sparsity\n"
  "  ncol = sp_h[1];\n"
  "  colind = sp_h+2; row = sp_h+ncol+3;\n"
  "  // Shift diagonal entries\n"
  "  for (c=0; c<ncol; ++c) {\n"
  "    for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "      if (row[k]==c) h[k] += reg;\n"
  "    }\n"
  "  }\n"
  "}\n";

const char* casadi_newton_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"newton_mem\"\n"
  "template<typename T1>\n"
  "struct casadi_newton_mem {\n"
  "  casadi_int n;\n"
  "  T1 abstol;\n"
  "  T1 abstol_step;\n"
  "  T1* x;\n"
  "  T1* g;\n"
  "  T1* jac_g_x;\n"
  "  const casadi_int* sp_a;\n"
  "  const casadi_int* sp_v;\n"
  "  const casadi_int* sp_r;\n"
  "  const casadi_int* prinv;\n"
  "  const casadi_int* pc;\n"
  "  T1* lin_w;\n"
  "  T1* lin_v;\n"
  "  T1* lin_r;\n"
  "  T1* lin_beta;\n"
  "};\n"
  "// C-REPLACE \"casadi_newton_mem<T1>\" \"struct casadi_newton_mem\"\n"
  "// SYMBOL \"newton\"\n"
  "template<typename T1>\n"
  "int casadi_newton(const casadi_newton_mem<T1>* m) {\n"
  "    // Check tolerance on residual\n"
  "    if (m->abstol>0 && casadi_norm_inf(m->n, m->g) <= m->abstol) return 1;\n"
  "    // Factorize J\n"
  "    casadi_qr(m->sp_a, m->jac_g_x, m->lin_w,\n"
  "              m->sp_v,  m->lin_v, m->sp_r, m->lin_r, m->lin_beta,\n"
  "              m->prinv, m->pc);\n"
  "    // Solve J^(-1) g\n"
  "    casadi_qr_solve(m->g, 1, 0, m->sp_v, m->lin_v, m->sp_r, m->lin_r, m->lin_beta,\n"
  "                    m->prinv, m->pc, m->lin_w);\n"
  "    // Update Xk+1 = Xk - J^(-1) g\n"
  "    casadi_axpy(m->n, -1., m->g, m->x);\n"
  "    // Check tolerance on step\n"
  "    if (m->abstol_step>0 && casadi_norm_inf(m->n, m->g) <= m->abstol_step) return 2;\n"
  "    // We will need another newton step\n"
  "    return 0;\n"
  "}\n";

const char* casadi_to_mex_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"to_mex\"\n"
  "template<typename T1>\n"
  "mxArray* casadi_to_mex(const casadi_int* sp, const T1* x) {\n"
  "  casadi_int nrow, ncol, nnz, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  mxArray *p;\n"
  "  double *d;\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "  casadi_int i;\n"
  "  mwIndex *j;\n"
  "#endif /* CASADI_MEX_NO_SPARSE */\n"
  "  nrow = *sp++;\n"
  "  ncol = *sp++;\n"
  "  nnz = sp[ncol];\n"
  "  colind = sp;\n"
  "  row = sp+ncol+1;\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "  if (nnz!=nrow*ncol) {\n"
  "    p = mxCreateSparse(nrow, ncol, nnz, mxREAL);\n"
  "    for (i=0, j=mxGetJc(p); i<=ncol; ++i) *j++ = *colind++;\n"
  "    for (i=0, j=mxGetIr(p); i<nnz; ++i) *j++ = *row++;\n"
  "    if (x) {\n"
  "      d = (double*)mxGetData(p);\n"
  "      for (i=0; i<nnz; ++i) *d++ = casadi_to_double(*x++);\n"
  "    }\n"
  "    return p;\n"
  "  }\n"
  "#endif /* CASADI_MEX_NO_SPARSE */\n"
  "  p = mxCreateDoubleMatrix(nrow, ncol, mxREAL);\n"
  "  if (x) {\n"
  "    d = (double*)mxGetData(p);\n"
  "    for (c=0; c<ncol; ++c) {\n"
  "      for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "        d[row[k]+c*nrow] = casadi_to_double(*x++);\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return p;\n"
  "}\n";

const char* casadi_from_mex_str =
  "// NOLINT(legal/copyright)\n"
  "// SYMBOL \"from_mex\"\n"
  "template<typename T1>\n"
  "T1* casadi_from_mex(const mxArray* p, T1* y, const casadi_int* sp, T1* w) {\n"
  "  casadi_int nrow, ncol, nnz, is_sparse, c, k;\n"
  "  const casadi_int *colind, *row;\n"
  "  size_t p_nrow, p_ncol;\n"
  "  mwIndex *Jc, *Ir;\n"
  "  const double* p_data;\n"
  "  if (!mxIsDouble(p) || mxGetNumberOfDimensions(p)!=2)\n"
  "    mexErrMsgIdAndTxt(\"Casadi:RuntimeError\",\n"
  "      \"\\\"from_mex\\\" failed: Not a two-dimensional matrix of double precision.\");\n"
  "  nrow = *sp++;\n"
  "  ncol = *sp++;\n"
  "  nnz = sp[ncol];\n"
  "  colind = sp;\n"
  "  row = sp+ncol+1;\n"
  "  p_nrow = mxGetM(p);\n"
  "  p_ncol = mxGetN(p);\n"
  "  is_sparse = mxIsSparse(p);\n"
  "  if (is_sparse) {\n"
  "#ifndef CASADI_MEX_NO_SPARSE\n"
  "    Jc = mxGetJc(p);\n"
  "    Ir = mxGetIr(p);\n"
  "#else /* CASADI_MEX_NO_SPARSE */\n"
  "    mexErrMsgIdAndTxt(\"Casadi:RuntimeError\",\n"
  "      \"\\\"from_mex\\\" failed: Sparse inputs disabled.\");\n"
  "#endif /* CASADI_MEX_NO_SPARSE */\n"
  "  }\n"
  "  p_data = (const double*)mxGetData(p);\n"
  "  if (p_nrow==1 && p_ncol==1) {\n"
  "    double v = is_sparse && Jc[1]==0 ? 0 : *p_data;\n"
  "    casadi_fill(y, nnz, v);\n"
  "  } else {\n"
  "    casadi_int tr = 0;\n"
  "    if (nrow!=p_nrow || ncol!=p_ncol) {\n"
  "      tr = nrow==p_ncol && ncol==p_nrow && (nrow==1 || ncol==1);\n"
  "      if (!tr) mexErrMsgIdAndTxt(\"Casadi:RuntimeError\",\n"
  "                                 \"\\\"from_mex\\\" failed: Dimension mismatch.\");\n"
  "    }\n"
  "    if (is_sparse) {\n"
  "      if (tr) {\n"
  "        for (c=0; c<ncol; ++c)\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]+c*nrow]=0;\n"
  "        for (c=0; c<p_ncol; ++c)\n"
  "          for (k=Jc[c]; k<Jc[c+1]; ++k) w[c+Ir[k]*p_ncol] = p_data[k];\n"
  "        for (c=0; c<ncol; ++c)\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) y[k] = w[row[k]+c*nrow];\n"
  "      } else {\n"
  "        for (c=0; c<ncol; ++c) {\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]]=0;\n"
  "          for (k=Jc[c]; k<Jc[c+1]; ++k) w[Ir[k]]=p_data[k];\n"
  "          for (k=colind[c]; k<colind[c+1]; ++k) y[k]=w[row[k]];\n"
  "        }\n"
  "      }\n"
  "    } else {\n"
  "      for (c=0; c<ncol; ++c) {\n"
  "        for (k=colind[c]; k<colind[c+1]; ++k) {\n"
  "          y[k] = p_data[row[k]+c*nrow];\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return y;\n"
  "}\n";

